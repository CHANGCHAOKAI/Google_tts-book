"""
檔案名稱:google_tts_voice_book.py
介紹:本系統是利用google_tts將讀者所要讀取的文章內容，
     以語音合成的技術合成出文章內容的語音檔，將文字
     與語音檔做結合並以karaoke的方式做呈現，以方便
     使用者可以用這樣的系統來幫助自己增加英文的聽力
     及閱讀口說能力。
作者:張朝凱
時間:2015/07/10
"""
from tkinter import *
#匯入tkinter作使用者介面的設計
from tkinter.filedialog import*
#匯入tkinter.filedialog讓使用者可以藉由滑鼠點選檔案
import requests
#匯入requests對googleTTS發出請求
import pygame
#匯入pygame運用pygame的mixer music播放mp3檔
import inflect
#匯入inflect將數字轉為英文 
p = inflect.engine()
import os, sys
import getpass
import CguAlign_wj_01
import time
import urllib.request
import urllib.parse
import romkan
import shutil
操作畫面 = Tk()
#先創造一個Tk物件名為操作畫面
文字顯示區 = Text(操作畫面, height=35, width=70)
#將Text物件加入root中並設其寬度為70和高度為35
global 文章      
#宣告全域變數並命名為文章
global 名稱
#宣告全域變數並命名為名稱
單位句子 = []
#單位句子是一個陣列，其陣列中的每個元素為文章內容依照順序切割
#字串長度不超過100的句子
去除標點符號的單位句子 = []
#將單位句子中的每個
去除標點符號的單位句子1 = []
單位句子中每個句子的檔案大小 = []
#宣告一個陣列用來存取單位句子中每個句子的檔案大小
文章集 = []
#宣告一個陣列用來存取合成過的文章檔名
文章字 = []
句子播放列表=[]
#創造一個空陣列名為句子播放列表用來存取句子語音同步播放時所需資料
單字播放列表=[]
#創造一個空陣列名為單字播放列表用來存取單字語音同步播放時所需資料
停用詞 = set((["at","on","in","from","and","that","for",
            "to","by","of","with","or","as"]))
#在此運用英文中常見的幾個介系詞和連接詞來構成停用詞來幫助
#我們將文章中過長的單位句子做進一步的切割
閱讀的文章 = []
##創造一個空陣列名為閱讀的文章用來存取播放語音的文章名稱
檔案路徑=os.getcwd()
#用os.getcwd()取得google_tts_voice_book.py檔的絕對路徑位置
語音開始 = False
語音播放 = False
IsPaseBool = True
#運用三個bool變數(語音開始,語音播放,IsPaseBool)來實做語音播放及語音暫停
句子播放句數=[]
#存取句子播放到第幾個句子
單字播放個數=[]
#存取單字播放到第幾個單字
暫停時間點 = []
#存取暫停時的時間點
單字拼音 = []
#存取每個字從google取得的拼音
拼音句子 = []
#存取每個非英文單位句子的google拼音
語音播放狀態 = []
標點符號編碼 = []
成功 = []
def 取得標點符號():
    
    標點符號查詢表檔案 = open("標點符號查詢表.txt","r",encoding = "utf-8")
    
    標點符號查詢表內容 = 標點符號查詢表檔案.read()
    
    標點符號查詢表 = 標點符號查詢表內容.split("\n")
    
    標點符號查詢表檔案.close()
    
    for i in 標點符號查詢表:
        
        編碼 = str(i).split("||")[0]
        
        標點符號編碼.append(編碼)
    
def google語音合成(檔案名稱):
    """
    將單位句子中的每一句句子上傳到GOOGLE做語音合成,
    將所有的句子語音寫入語音檔案形成整篇文章的語音,
    並紀錄所有句子的音訊內容大小於單位句子中每個句子的檔案大小中。
    """
    
    GOOGLE_TTS_URL ='http://translate.google.com/translate_tts'
    #設定googletts的網址
    
    文字語言 = []
    #宣告一個空陣列名為文字語言
    
    for i in range(0,len(單位句子),1):
    #用for迴圈將單位句子中的每一個元素依序
    #加入文字語言並在每個元素後加上其語言種類
        
        語言 = 'en'
        #設定語言種類為'en'英文
        
        句子 = 單位句子[i]
        #設定句子為單位句子
        
        文字語言+=[(句子,語言)]
        #最後依序加入文字語言中
        
    語音檔存取位置 =  r'%s\%s'%(檔案路徑,"Output\mp3")
    
    語音檔案名稱 = 檔案名稱
    
    完整名稱 = os.path.join(語音檔存取位置,檔案名稱)
    
    語音檔案 = open(完整名稱,'wb')
    #開啟一個新的檔案名為語音檔案用來存取語音內容
    
    for idx,句子語言 in enumerate(文字語言):
    #用for迴圈取得每句話的idx
        
        句子,語言 = 句子語言
        #將文字語言內的句子和語言分別傳入句子,語言
        
        payload = { 'ie':'utf8',
                    'tk':'308912',
                    'client':'t',
                    'tl':語言,
                    'q':句子,
                    'total':len(文字語言),
                    'idx':idx,
                    'textlen':len(句子)}
        #pyload是將文章傳給google做語音合成所需具備的
        #參數其含有'ie':(編碼的格式)'tl':(合成所需的語言)
        #'q':(每次要合成的句子)'total':(共有多少句子需做語音合成)
        #'idx':(每個句子的檔案大小)'textlen':(每次要合成的句子長度)
        
        try:
            
            暫存檔案 = requests.get(GOOGLE_TTS_URL,params=payload)
            #用requests.get()對google送出請求並取得每次要合成語音的
            #語音內容並存入暫存檔案中
            
            每句和成句子的檔案大小 = len(暫存檔案.content)
            #用len取得暫存檔案.content的長度即為每句和成句子的檔案大小
            
            語音檔案.write(暫存檔案.content)
            #將所有的暫存檔案都寫入語音檔案
            
            單位句子中每個句子的檔案大小.append(每句和成句子的檔案大小)
            #將每句和成句子的檔案大小加入單位句子中每個句子的檔案大小的
            #這個陣列中
            
        except Exception as e:
            raise
        
    語音檔案.close()
    #當所有句子的語音內容都寫入時將語音檔案關閉
           
def 第二步文字處理(i):
    """
    第二步文字處理的目的是針對文字處理後那些長度大於101的句子,
    運用程式剛開始所宣告的停用詞來做切割,其停用詞的目的是用來
    切割那些經由符號切割後長度還是大於101的句子,因為句子內已不
    含任何標點符號為了切割必須想辦法從文字的部分做處理,為了可以
    切割又不會影響句子的本身意思,所以用了英文句子中常見的介系詞和
    連接詞所構成的停用詞來做切割的依據。最後再把經由符號切割後
    長度還是大於101的句子依停用詞做切割加入單位句子中。
    input(較小的句子[i])
    較小的句子[i]:為文章內容經由標點符號切割後長度還是大於100的句子
    """
    句子中的字= i.split()
    #在此將句子以字為單位做切割
     
    暫存字組 = []
    #先宣告一個空陣列名為暫存字組
    #存取那些過長句子中經由處理過的每個字
     
    for i in range(0,len(句子中的字),1):
    #利用for迴圈針對句子中的每個字做判斷
         
         if 句子中的字[i] in 停用詞:
         #假如這個字是屬於停用詞
              
             句子中的字[i] = '@'+句子中的字[i]
             #則在這個字前加上@符號
              
             暫存字組.append(句子中的字[i])
             #並加入暫存字組
              
         else:
         #假如這個字不屬於停用詞
              
             句子中的字[i] = ' '+句子中的字[i]
             #則在這個字前加上' '符號
              
             暫存字組.append(句子中的字[i])
             #並加入暫存字組
              
    句子 = ''.join(i for i in 暫存字組)
    #最後將暫存字組中的所有元素依序做銜接形成新的句子
     
    del 暫存字組[:]
    #當新的句子產生後必須將暫存字組做清空的動作
    #以便供給下一個句子使用
     
    符號位置 = []
    #創造一個空陣列名為符號位置用來存取
    #句子中每一個停用詞在句子中的位置
     
    for i,c in enumerate(句子):
    #用for迴圈及enumerate去檢查句子中每個字母符號
         
        if c=='@':
        #假如檢查到符號@
             
            符號位置.append(i)
            #則將符號在句子中的位置加入符號位置
             
    符號位置.append(len(句子))
    #最後再加入句子的長度
     
    中間位置 = len(符號位置)//2
    #找出符號位置中間的元素
     
    if len(符號位置)%2==1:
    #假設符號位置內元素的總數為單數
         
        切割位置 = 符號位置[中間位置]
        #則取出中間的元素為切割位置
         
        if 切割位置>100:
        #假設切割位置大於100
             
            單數百以內切割位置 = [ ]
            #創造一個空陣列名為單數百以內切割位置
            #用來存取長度100以內的切割位置
             
            for i in range(0,len(符號位置),1):
            #運用for迴圈將小於100以內的符號位置加入單數百以內切割位置
                 
                if 符號位置[i] <100:
                #假如符號位置小於100
                     
                    單數百以內切割位置.append(符號位置[i])
                    #則將符號位置加入單數百以內切割位置
                     
                切割位置 = 單數百以內切割位置[-1]
                #將切割位置設為單數百以內切割位置的最後一個元素
                 
    else:
    #假設符號位置內元素的總數為偶數
         
        切割位置 = 符號位置[中間位置-1]
        #因為元素總數為偶數沒辦法取出中間數
        #所以取中間數的前一個數為切割位置
         
        if 切割位置>100:
        #假設切割位置大於100
             
            雙數百以內切割位置 = []
            #創造一個空陣列名為雙數百以內切割位置
            #用來存取長度100以內的切割位置
             
            for i in range(0,len(符號位置),1):
            #運用for迴圈將小於100以內的符號位置加入雙數百以內切割位置
                 
                if 符號位置[i]<100:
                #假如符號位置小於100
                     
                    雙數百以內切割位置.append(符號位置[i])
                    #則將符號位置加入雙數百以內切割位置
                     
                切割位置 = 雙數百以內切割位置[-1]
                #將切割位置設為單數百以內切割位置的最後一個元素
                 
    字組 = list(句子)
    #將句子以單字為單位做切割行成名為字組的list
     
    字組[切割位置]="///"
    #將字組中切割的位置以"///"做標示
     
    for i in 字組:
    #運用for迴圈將字組內所有元素依序做銜接
         
        句子 = ''.join(i for i in 字組)
         
    句子 = 句子.replace('@',' ')
    #去除句子中除了切割位置之外的其他符號
     
    句子組2 = 句子.split("///")
    #將句子以切割位置做切割形成句子為單位的list
     
    for i in 句子組2:
    #運用for迴圈依序把句子組2的句子加入單位句子
 
        if len(i)>0:
         
            單位句子.append(i)
    句子 = ''.join(i for i in 暫存字組)
    #最後將暫存字組中的所有元素依序做銜接形成新的句子
    
    del 暫存字組[:]
    #當新的句子產生後必須將暫存字組做清空的動作
    #以便供給下一個句子使用
    print(len(句子),句子)
    停用詞句子組 = 句子.split("@")

    for sentence in 停用詞句子組:

        sentence = sentence.strip()
        
        單位句子.append(sentence)
    
def 去除標點符號(i):
 
    輸入 = str(i)
 
    輸出 = ""
 
    for 字元 in 輸入:
 
        if str(ord(字元)) not in 標點符號編碼:
 
            輸出 = 輸出+字元
             
    return 輸出        

def 數字轉英文(i):
 
    數字長度 = len(i)
 
    if 數字長度 == 4:
 
        數字英文 = p.number_to_words(str(i),group=2)
 
        純數字英文 = 數字英文.replace(" ","")

        純數字英文 = 去除標點符號(純數字英文)
 
        return 純數字英文
 
    if 數字長度<4:
 
        數字英文 = p.number_to_words(str(i),andword='')
         
        純數字英文 = 數字英文.replace(" ","")

        純數字英文 = 去除標點符號(純數字英文)
         
        return 純數字英文

    if 數字長度>4:

        數字英文 = p.number_to_words(str(i),group=1)

        純數字英文 = 數字英文.replace(" ","")

        純數字英文 = 去除標點符號(純數字英文)

        return 純數字英文

def 去除標點符號的單位句子數字轉英文():

    暫存 = []
    
    for i in 去除標點符號的單位句子:

        輸入 = str(i)
        
        字組 = 輸入.split()

        for 字 in 字組:

           檢查字串 = str(字)

           數字檢查 = re.search(r"(\d)",檢查字串)

           if str(數字檢查) =="None":
           #如果數字檢查結果為None則代表檢查字串內容為純英文
               
               暫存.append(檢查字串)
               
           if str(數字檢查) !="None":
           #如果數字檢查結果不為None則代表檢查字串內容為含數字的字串

               含數字字串 = 檢查字串

               純數字字串檢查 = re.search('[a-zA-Z]',含數字字串)

               if str(純數字字串檢查) =="None":
               #如果純數字字串檢查為None在此含數字字串為純數字字串

                   純數字 = 含數字字串

                   純數字英文 = 數字轉英文(純數字)

                   暫存.append(純數字英文)

               if str(純數字字串檢查) !="None":
               #如果純數字字串檢查不為None在此含數字字串為數字加英文字串

                   數字加英文字串 = 含數字字串

                   英文 = ""
 
                   for 字母 in 數字加英文字串:
 
                        if 字母.isalpha():
 
                            英文= 英文+字母

                   數字 = str(數字加英文字串).replace(str(英文),'')

                   純數字英文 = 數字轉英文(數字)

                   if str(數字加英文字串[0]).isalpha():

                       數字加英文字串 = str(英文)+str(純數字英文)

                       暫存.append(純數字英文)
                   else:

                       數字加英文字串 = str(純數字英文)+str(英文)

                       暫存.append(純數字英文)
        句子 = ""

        for  i in 暫存:
            word = str(i)+" "
            句子 = 句子+word
        去除標點符號的單位句子1.append(句子)
        del 暫存[:]

def 尋找符號位置(內容,符號):
    """
    此function 主要是用來搜尋句子中的符號位置
    
    內含兩個變數內容,符號其中內容表示文章內容的字串內容
    
    符號表示要搜尋的符號
    """
    return [i for i, letter in enumerate(內容) if letter == 符號]
   
def 文字處理(i):
    """
    文字處理最主要的目的將文章內容經由切割後產生長度小於101的
    句子來盡可能去符合google tts 的上傳限制,首先是針對文章中
    的幾個主要的標點符號做切割(. ? : ; ! -- )以上的符號就是
    文章中主要代表句子結束的標點符號,當文章經由上述符號切割之後,
    如果發現句子還是過長時則在經由句子中的逗號(,)做切割的動作,
    如果還是發現切割後的句子長度大於101時則將此句子交由
    第二步文字切割處理做切割處理,處理完後會把文章內容依每句長度
    不超過101的句子做依序的換行列出。
    input = i(文章內容字串)
    """
    i = i.replace("\n\n","\n")
    #將連續兩個換行符號替換成一個換行符號

    換行符號 ='\n'
    
    換行符號位置 = 尋找符號位置(i,換行符號)
    #搜尋換行符號在文章string中的index

    檢查符號=[".","?","!","]",")",":"," -- "]
    #搜尋以下符號

    檢查符號2 = ["[","("]   

    切割位置 = []
    #創立切割位置list

    for 符號 in 檢查符號:

        檢查符號位置 = 尋找符號位置(i,符號)
        #取得文章中所有檢察符號的index()

        切割位置.extend(檢查符號位置)
        #並加入切割為誌中

    for 符號 in 檢查符號2:

        檢查符號位置2 = 尋找符號位置(i,符號)
        
        檢查符號位置3 = []
        if len(檢查符號位置2)!=0:
            for q in 檢查符號位置2:

                t = int(q)-1
                if t not in 切割位置:
                    
                    切割位置.append(t)

    for k in 換行符號位置:

        if int(k)-1 not in 切割位置:
        #將換行符號減一做檢查如果在則標示所有句
        #子的結束位置以標記如果不在代表有的句子
        #結尾是沒有標點符號或是其他特殊服號

            切割位置.append(int(k)-1)
            #將沒出現過的位置加入切割位置
    
    切割位置1=sorted(切割位置)
    #用sorted將切割位置內的元素由小到大依序排列

    刪除點=[] 

    for a in range(0,len(切割位置1)-1,1):
    #用迴圈檢察切割位置       

        if int(切割位置1[a+1])-int(切割位置1[a])==1:
        #如果彼此相檢結果為1表示句子結尾有符號相連       

            刪除點.append(int(切割位置1[a]))
            #相連時紀錄最小者於刪除點
    
    for 點 in 刪除點:
    #用刪除點去除切割位置1內相鄰最小者

        if 點 in 切割位置1:

            切割位置1.remove(點)
    
    句子組 = []

    起始 = int(0)

    for s in range(0,len(切割位置1),1):

        結束 = int(切割位置1[s])+1

        句子 = i[起始:結束]

        句子 = 句子.strip()

        句子組.append(句子)

        起始 = 結束

    for g in range(0,len(句子組),1):
    #運用for迴圈檢查每一個經由上述符號切割過的句子長度

        句子長度 = len(句子組[g])
        
        if(句子長度)< 101 and (句子長度)>0:
        #假設句子長度小於101且大於0時
            
            單位句子.append(句子組[g])
            #將此句子加入單位句子

        if(句子長度)>=101:
        #假如句子長度大於101時

            過長句子 = str(句子組[g])

            過長句子 = 過長句子.replace(",",",@")

            較小的句子 = 過長句子.split("@")

            for i in range(0,len(較小的句子),1):
            #運用for迴圈檢查每一個經由逗號切割過的句子長度

                較小的句子長度 = len(較小的句子[i])

                if(較小的句子長度)<101 and (較小的句子長度)>0:
                #假設句子長度小於101且大於0時
                    
                    單位句子.append(較小的句子[i])
                    #將此句子加入單位句子

                else:
                    第二步文字處理(較小的句子[i])
                    #如果句子長度還是大於101則呼叫第二步文字處理

    for i in range(0,len(單位句子),1):
    #運用for迴圈將所有單位句子內的句子去除句子前的空白
    #因為不把句子純文字化在搜尋句子在畫面的位置時會發生錯誤

        單位句子[i] = 單位句子[i].strip()
        #用strip()將單位句子中純文字的部分取出

    for k in 單位句子:

        if len(k)==0:

            單位句子.remove(k)
    for g in 單位句子:

        去除符號 = 去除標點符號(str(g))

        if len(去除符號)==0:

            單位句子.remove(g)

    for i in range(0,len(單位句子),1):

        輸入 = 單位句子[i]

        空白 = ""

        for 字元 in 輸入:

            if str(ord(字元)) not in 標點符號編碼:

                空白 = 空白+ 字元

        去除標點符號的單位句子.append(空白)

    去除標點符號的單位句子數字轉英文()
def mp3_to_wav():
    """
    在此運用ffmpeg將mp3檔案轉為wav,並由ffmpeg所產生的log檔將語音長度取出
    並進行換算取得語音檔的總長度(單位為毫秒)
    output = 總共秒數
    """
    
    d="ffmpeg -report -y -i ./Output/mp3/{0}.mp3 -ar 16000 ./cgualign_lite/Input/{1}.wav"
    s="ffmpeg -i ./cgualign_lite/Input/{0}.wav -y -ar 16000 ./Output/mp3/{1}.mp3"
    os.system(str(d).format(文章集[-1],文章集[-1]))
    os.system(str(s).format(文章集[-1],文章集[-1]))
    #運用os.system呼叫ffmpeg將從google tts合成的mp3
    #轉為wav格式並存入名為wav的資料夾
    #ffmpeg最後會在資料夾中產生紀錄檔例如(ffmpeg-20150731-164152.log)
    
    資料夾中的所有檔案= os.listdir()
    #用os.listdir()取得資料夾中的所有檔案
    
    for 檔案 in 資料夾中的所有檔案:
    #用for迴圈搜尋資料夾中的檔案
        
        if 檔案.startswith("ffmpeg") and 檔案.endswith(".log"):
        #假如檔名以"ffmpeg"開頭並且副檔名為".log"
            
            報告檔案 = 檔案
            #則將檔案存入名為報告檔案的變數
            
            break
        
    報告檔案內容 = open(報告檔案,"r")
    #將報告檔案開啟存入名為報告檔案內容的變數
    
    for i in 報告檔案內容:
    #用for迴圈搜尋報告檔案內容
        
        if i.find("Duration:")!=-1:
        #假如搜尋到"Duration:"
            
            wav檔案語音長度 = i.split("  Duration: ")[1].split(",")[0]
            #將wav檔案的語音長度取出
            
            小時 = int(wav檔案語音長度.split(":")[0])
            
            分鐘 = int(wav檔案語音長度.split(":")[1])
            
            秒 = float(wav檔案語音長度.split(":")[2])
            #分別把語音長度中的小時'分鐘'秒取出
            
            總共秒數 = int(小時*3600000+分鐘*60000+秒*1000)
            #最後再把小時'分鐘'秒進行單位換算(單位為:毫秒)進行加總
            
    報告檔案內容.close()
    #將報告檔案關閉
    
    os.system("del "+報告檔案)
    #然後進行刪除
    
    return 總共秒數

def 製作sentence_level_sbv檔(j):
    """
    運用單位句子中的句子跟mp3_to_wav所取出的總共秒數
    乘上單位句子中每個句子的檔案大小在語音檔案大小所
    占的比例來求得每個句子的時間長來求得每個句子在播
    放時的開始時間及結束時間
    input(j):j代表wav語音的時間長度
    """
    
    檔案大小 = sum(單位句子中每個句子的檔案大小)
    #用sum將單位句子中每個句子的檔案大小中所有的元素做相加取得檔案大小
    
    開始時間 = 0.0
    #設定開始時間為0.0
    
    sbv寫入內容 = ""
    #設定sbv寫入內容
    
    for i in range(0,len(單位句子中每個句子的檔案大小),1):
    #運用for迴圈求取句子播放時的開始時間及結束時間
        
        開始時間_小時 = int(開始時間/3600)
        #將時間做換算取出開始時間_小時
        
        開始時間_分鐘 = int((開始時間%3600)/60)
        #將時間做換算取出開始時間_分鐘
        
        開始時間_秒 = 開始時間%60
        #將時間做換算取出開始時間_秒
        
        句子檔案 = 單位句子中每個句子的檔案大小[0:i+1]
        #取得所有句子累加的大小
        
        句子的時間百分比 = sum(句子檔案)/檔案大小
        #求出句子檔案在檔案大小中所佔的比例存入名為句子的時間百分比
        
        結束時間=(j*句子的時間百分比)/1000
        #運用mp3_to_wav所取出的總共秒數乘上句子的時間百分比取得句子的時間長度
        
        結束時間_小時 = int(結束時間/3600)
        #將時間做換算取出結束時間_小時
        
        結束時間_分鐘 = int((結束時間%3600)/60)
        #將時間做換算取出結束時間_分鐘
        
        結束時間_秒 = 結束時間%60
        #將時間做換算取出結束時間_秒
        
        sbv寫入內容+="{0}:{1}:{2:f},{3}:{4}:{5:f}\n".format(開始時間_小時,
        開始時間_分鐘,開始時間_秒,結束時間_小時,結束時間_分鐘,結束時間_秒)
        #將開始時間_小時,開始時間_分鐘,開始時間_秒,
        #結束時間_小時,結束時間_分鐘,結束時間_秒寫入sbv寫入內容
        
        sbv寫入內容+=去除標點符號的單位句子1[i]+"\n\n"
        
        開始時間 = 結束時間
        
    路徑 = "./cgualign_lite/Input/"
    
    sbv檔案= open(str(路徑)+文章集[-1]+".sbv","w+",encoding="utf-8")
    #以點選文章的名稱做檔案名稱另存sbv檔於sentence_level_SBV資料夾中
    
    sbv檔案.write(sbv寫入內容)
    #將sbv寫入內容寫入sbv檔案
    
    sbv檔案.close()
    #將sbv檔案關閉
    
def 製作句子語音同步列表(j):
    """
    運用從cgulign_lite中Input內的sbv檔來製作句子語音同步用的資料表
    其內容為(句子,畫面中句子的起始位置,畫面中句子的結束位置,
    句子在wav檔中的播放起始時間,句子在wav檔中的播放結束時間)
    input:j 為文字顯示區
    """
    
    路徑 = "./cgualign_lite/Input/"
    
    sentence_level_sbv = open(str(路徑)+文章集[-1]+".sbv","r",encoding="utf-8")
    #先取出cgulign_lite中Input內的sbv檔
    
    sentence_level_sbv內容 = sentence_level_sbv.read()
    #將sbv檔用read()做讀取
    
    sentence_level_sbv.close()
    
    sentence_level_sbv內容 = sentence_level_sbv內容.replace('\n\n','\n')
    #先將兩個換行符號做替換,換成一個換行符號用來消除sbv檔中的空行
    
    sentence_level_sbv內容列表 = sentence_level_sbv內容.split('\n')
    #接著以換行符號做切割,分割出句子和時間其時間包含起始時間和結束時間
    
    時間列表 = []
    #創造時間列表用來存取時間
    
    for i in range(0,len(sentence_level_sbv內容列表),1):
    #用for迴圈分別將句子存入句子列表,將時間存入時間列表
        
        if i%2==0 and len(sentence_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後時間的部分在list中的單數元素
            
            時間列表.append(sentence_level_sbv內容列表[i])
            #所以將單數元素存入時間列表
            
    時間字串 = ""
    #創造時間字串用來連接所有時間列表內的所有元素
    
    for i in range(0,len(時間列表),1):
    #用for迴圈依序將所有在時間列表內的元素做銜接
        
        時間字串+=時間列表[i]+","
        #並在元素之間加上逗號","
        
    時間列表2 =時間字串.split(',')
    #最後用逗號做切割產生時間列表
    
    開始時間 = []
    #創造開始時間用來存取每個句子在播放時的起始時間
    
    結束時間 = []
    #創造結束時間用來存取每個句子在播放時的結束時間
    
    暫存 = []
    #創造暫存用來存取句子語音同步資料字串
    
    for i in range(0,len(時間列表2),1):
    #用for迴圈分別將句子在播放時的起始時間存入開始時間,
    #句子在播放時的結束時間存入結束時間
        
        if i%2==0 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #句子在播放時的起始時間在時間列表2這個list的單數元素
            
            開始時間.append(時間列表2[i])
            #將句子在播放時的起始時間存入開始時間
            
        if i%2==1 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #句子在播放時的結束時間在時間列表2這個list的偶數元素
            
            結束時間.append(時間列表2[i])
            #將句子在播放時的結束時間存入結束時間
            
    句子起始位置='1.0'
    #設定句子起始位置為'1.0'其1為列數0為行數
    
    for i in range(0,len(開始時間),1):
    #設立for迴圈將每個句子在畫面中的位置找出來
        
        句子 = 單位句子[i]
        #依序將句子列表內的元素存入名為句子的變數
        
        句子起始位置 = 文字顯示區.search(句子,句子起始位置)
        #運用文字顯示區.search找出每個句子在文字顯示區的開始位置
        
        if not 句子起始位置:
        #設定判斷式假如找不到句子起始位置則跳出
            
            print(句子+"can't find the location")
            
            break
        
        句子起始位置和句子長度 = '%s+%dc' %(句子起始位置,len(句子))
        
        句子結束位置 = 文字顯示區.index(句子起始位置和句子長度)
        #將句子起始位置加上句子本身長度來計算出句子結束位置
        
        開始_時_分_秒 = 開始時間[i].split(':')
        #將開始時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        句子開始時間 = (int(開始_時_分_秒[0])*3600000
                      +int(開始_時_分_秒[1])*60000
                      +int(float(開始_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        結束_時_分_秒 = 結束時間[i].split(':')
        #將結束時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        句子結束時間 =(int(結束_時_分_秒[0])*3600000
                     +int(結束_時_分_秒[1])*60000
                     +int(float(結束_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        句子語音同步資料字串 = (str(句子)+"||"
                             +str(句子起始位置)+"||"
                             +str(句子結束位置)+"||"
                             +str(句子開始時間)+"||"
                             +str(句子結束時間)+"\n")
        #將所有句子語音同步資料轉為字串存入名為句子語音同步資料字串的變數
        
        暫存.append(句子語音同步資料字串)
        #將所有句子語音同步資料字串依序加入暫存
        
        句子起始位置 = 句子結束位置
        #將句子結束位置設為句子起始位置準備找尋下一個句子的句子結束位置
        
    句子語音同步列表字串 = ''.join(i for i in 暫存)
    #用for迴圈將暫存中的句子語音同步資料字串依序做銜接
    
    del 暫存[:]
    
    del 結束時間[:]
    
    del 開始時間[:]
    
    del 時間列表[:]
    
    return 句子語音同步列表字串

def 製做單字語音同步列表(j):
    """
    運用從cgulign_lite中Output內的切到字的sbv檔資料夾中的
    sbv檔來製作單字語音同步用的資料表
    其內容為(單字,畫面中單字的起始位置,畫面中單字的結束位置,
    單字在wav檔中的播放起始時間,單字在wav檔中的播放結束時間)
    input:j 為文字顯示區
    """
    
    路徑 = "./cgualign_lite/Output/切到字的sbv檔/"
    
    word_level_sbv = open(str(路徑)+文章集[-1]+".sbv","r",encoding="utf-8")
    #先取出cgulign_lite中Output內的切到字的sbv檔資料夾中的sbv檔
    
    word_level_sbv內容 = word_level_sbv.read()
    #將sbv檔用read()做讀取
    
    word_level_sbv.close()
    
    word_level_sbv內容 = word_level_sbv內容.replace('\n\n','\n')
    #先將兩個換行符號做替換,換成一個換行符號用來消除sbv檔中的空行
    
    word_level_sbv內容列表 = word_level_sbv內容.split('\n')
    #接著以換行符號做切割,分割出單字和時間其時間包含起始時間和結束時間
    
    時間列表 = []
    #創造時間列表用來存取時間
    
    單字列表 = []
    #創造單字列表用來存取單字
    
    for i in range(0,len(word_level_sbv內容列表),1):
    #用for迴圈分別將單字存入單字列表,將時間存入時間列表
        
        if i%2==0 and len(word_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後時間的部分在list中的單數元素
            
            時間列表.append(word_level_sbv內容列表[i])
            #所以將單數元素存入時間列表
            
        if i%2==1 and len(word_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後單字的部分在list中的偶數元素
            
            單字列表.append(word_level_sbv內容列表[i])
            #所以將偶數元素存入單字列表
            
    時間字串 = ""
    #創造時間字串用來連接所有時間列表內的所有元素
    
    for i in range(0,len(時間列表),1):
    #用for迴圈依序將所有在時間列表內的元素做銜接
        
        時間字串+=時間列表[i]+","
        #並在元素之間加上逗號","
        
    時間列表2 =時間字串.split(',')
    #最後用逗號做切割產生時間列表
    
    開始時間 = []
    #創造開始時間用來存取每個單字在播放時的起始時間
    
    結束時間 = []
    #創造結束時間用來存取每個單字在播放時的結束時間
    
    暫存 = []
    #創造暫存用來存取單字語音同步資料字串
    
    for i in range(0,len(時間列表2),1):
    #用for迴圈分別將單字在播放時的起始時間存入開始時間,
    #單字在播放時的結束時間存入結束時間
        
        if i%2==0 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #單字在播放時的起始時間在時間列表2這個list的單數元素
            
            開始時間.append(時間列表2[i])
            #將單字在播放時的起始時間存入開始時間
            
        if i%2==1 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #單字在播放時的結束時間在時間列表2這個list的偶數元素
            
            結束時間.append(時間列表2[i])
            #將單字在播放時的結束時間存入結束時間
            
    單字起始位置='1.0'
    #設定單字起始位置為'1.0'其1為列數0為行數
    
    for i in range(0,len(開始時間),1):
    #設立for迴圈將每個單字在畫面中的位置找出來
        
        單字 = 文章字[i]
        
        word = 單字列表[i]
        #依序將單字列表內的元素存入名為單字的變數
        
        單字起始位置 = 文字顯示區.search(單字,單字起始位置)
        #運用文字顯示區.search找出每個單字在文字顯示區的開始位置
        
        if not 單字起始位置:
        #設定判斷式假如找不到單字起始位置則跳出
            
            print(單字+"can't find the location")
            
            break
        
        單字起始位置和單字長度 = '%s+%dc' %(單字起始位置,len(單字))
        
        單字結束位置 = 文字顯示區.index(單字起始位置和單字長度)
        #將單字起始位置加上單字本身長度來計算出單字結束位置
        
        開始_時_分_秒 = 開始時間[i].split(':')
        #將開始時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        單字開始時間 = (int(開始_時_分_秒[0])*3600000
                      +int(開始_時_分_秒[1])*60000
                      +int(float(開始_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        結束_時_分_秒 = 結束時間[i].split(':')
        #將結束時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        單字結束時間 = (int(結束_時_分_秒[0])*3600000
                      +int(結束_時_分_秒[1])*60000
                      +int(float(結束_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        單字語音同步資料字串 = (str(單字)+"||"
                             +str(單字起始位置)+"||"
                             +str(單字結束位置)+"||"
                             +str(單字開始時間)+"||"
                             +str(單字結束時間)+"\n")
        #將所有單字語音同步資料轉為字串存入名為單字語音同步資料字串的變數
        
        暫存.append(單字語音同步資料字串)
        #將所有句子語音同步資料字串依序加入暫存
        
        單字起始位置 = 單字結束位置
        #將單字結束位置設為單字起始位置準備找尋下一個單字的單字結束位置
        
    單字語音同步列表字串 = ''.join(i for i in 暫存)
    #用for迴圈將暫存中的單字語音同步資料字串依序做銜接
    
    del 暫存[:]
    
    del 結束時間[:]
    
    del 開始時間[:]
    
    del 單字列表[:]
    
    del 時間列表[:]
    
    return 單字語音同步列表字串

def 製做句子播放列表(k):
    
    句子單字語音同步資料 = open("./Output/tlt/"+k+".tlt","r",encoding="utf-8")
    #開啟句子語音同步列表內的句子語音同步資料
    
    句子單字語音同步資料內容 =句子單字語音同步資料.read()
    
    句子單字語音同步資料.close()
    
    句子單字語音同步資料內容1 = 句子單字語音同步資料內容.split("@@")
    
    句子語音同步資料內容 = str(句子單字語音同步資料內容1[0])
    
    句子1 = 句子語音同步資料內容.split("\n")
    #將內容先以換行符號做切割
    
    句子2 = 句子1[0:len(句子1)-1]
    #由於上述的切割方式最後會產生一個" "的元素
    #因此取第一個到倒數第二個元素為新的陣列
    
    for i in 句子2:
    #運用for迴圈將語音播放時所用的資料加入句子播放列表
        
        句子資料 = i.split("||")
        
        句子字串 =  句子資料[0]
        
        句子畫面起始位置 = 句子資料[1]
        
        句子畫面結束位置 = 句子資料[2]
        
        句子語音開始秒數 = 句子資料[3]
        
        句子語音結束秒數 = 句子資料[4]
        
        句子播放資料 = (句子字串,句子畫面起始位置,
                       句子畫面結束位置,句子語音開始秒數,句子語音結束秒數)
        
        句子播放列表.append(句子播放資料)
    
def 製做單字播放列表(k):
    
    句子單字語音同步資料 = open("./Output/tlt/"+k+".tlt","r",encoding="utf-8")
    #開啟單字語音同步列表內的單字語音同步資料
    
    句子單字語音同步資料內容 =句子單字語音同步資料.read()
    
    句子單字語音同步資料.close()
    
    句子單字語音同步資料內容1 = 句子單字語音同步資料內容.split("@@")
    
    單字語音同步資料內容 = str(句子單字語音同步資料內容1[1])
    
    單字1 = 單字語音同步資料內容.split("\n")
    #將內容先以換行符號做切割
    
    單字2 = 單字1[0:len(單字1)-1]
    #由於上述的切割方式最後會產生一個" "的元素
    #因此取第一個到倒數第二個元素為新的陣列
    
    for i in 單字2:
    #運用for迴圈將語音播放時所用的資料加入單字播放列表
        
        單字資料 = i.split("||")
        
        單字字串 =  單字資料[0]
        
        單字畫面起始位置 = 單字資料[1]
        
        單字畫面結束位置 = 單字資料[2]
        
        單字語音開始秒數 = 單字資料[3]
        
        單字語音結束秒數 = 單字資料[4]
        
        單字播放資料 =(單字字串,單字畫面起始位置,
                      單字畫面結束位置,單字語音開始秒數,單字語音結束秒數)
        
        單字播放列表.append(單字播放資料)
    
def 開始閱讀():
    """
    運用句子播放列表及單字播放列表將文字搭配上語音
    以karaoke的方式展現並運用pygame的pouse及unpouse
    做暫停和繼續撥放的動作
    """
    
    global 語音開始,語音播放,IsPaseBool
    #運用先前宣告的語音開始,語音播放,IsPaseBool
    #等布林代數來控制語音的暫停與繼續播放
    
    文字顯示區.tag_configure('highlight',background='yellow')
    #用tag_configure('highlight',background='yellow')顯示句子語音當下的內容
    
    文字顯示區.tag_configure('found',foreground='red')
    #用tag_configure('found',foreground='red')顯示單字語音當下的內容
    
    if not 語音播放:
        
        if not 語音開始:
            
            pygame.mixer.music.play()
            #用pygame.mixer.music.play撥放語音內容
            
            語音播放狀態.append("T")
            
            語音開始 = True
            
            語音播放 = not 語音播放
            
            n= 0
            
            tmpBool = True
            
            n2 = 0
            
            tmpBool2 = True
            
            現在語音播放時間 = pygame.mixer.music.get_pos()
            #用pygame.mixer.music.get_pos()取出現在語音播放時間
            
            if 現在語音播放時間==-1:
                
                去除文字顯示區的效果()
                
            while 現在語音播放時間!=-1 and IsPaseBool==True:
            #當現在語音播放時間不等於-1時代表語音還在播放狀態
                
                現在語音播放時間 = pygame.mixer.music.get_pos()
                
                if n<len(句子播放列表):
                #當n小於句子播放列表時
                    
                    文字顯示當n小於句子播放列表(現在語音播放時間,n,tmpBool)
                    
                    tmpBool = False
                    
                    if 現在語音播放時間>=int(句子播放列表[n][4]):
                    #假設現在語音播放時間大於等於現在語音播放時間
                    #代表此句子的語音內容已播放完畢
                        
                       n+=1
                       #則把n加一進入下一個句子的播放狀態
                       
                    tmpBool = True
                    
                if n == len(句子播放列表):
                    
                    文字顯示當n等於句子播放列表()
                    
                    語音開始 = False
                    
                    語音播放 = False
                    
                    IsPaseBool = True
                    
                    break
                
                if n2<len(單字播放列表):
                    
                    文字顯示當n2小於單字播放列表(現在語音播放時間,n2,tmpBool2)
                    
                    tmpBool2 = False
                    
                    if 現在語音播放時間>=int(單字播放列表[n2][4]):
                    #假設現在語音播放時間大於等於現在語音播放時間
                    #代表此單字的語音內容已播放完畢
                        
                        n2+=1
                        #則把n2加一進入下一個單字的播放狀態
                        
                    tmpBool2 = True
                    
                if n2 == len(單字播放列表):
                #當n2等於單字播放列表的長度時
                    
                    文字顯示區.tag_remove('found',單字播放列表[-1][1],
                    單字播放列表[-1][2])
                    #運用tag_remove()去除最後一個單字的顯示效果
                    
                if IsPaseBool ==False:
                #假設IsPaseBool等於False
                    
                    文字顯示區當IsPaseBool等於False(n,n2)
                    
                    break
                
        else:
            pygame.mixer.music.unpause()
            #用pygame.mixer.music.unpause取消語音的暫停
            
            if (語音播放狀態[-1]=='restart'
                and 語音播放狀態[-2]=='F'):
                
               n=len(句子播放列表)
               
               句子播放句數.append(len(句子播放列表))
               
               單字播放個數.append(len(單字播放列表))
               
            if (語音播放狀態[-1]=='restart'
                and 語音播放狀態[-2]=='restart'):
                
               n=len(句子播放列表)
               
               句子播放句數.append(len(句子播放列表))
               
               單字播放個數.append(len(單字播放列表))
               
            語音播放狀態.append("T")
            
            IsPaseBool= True
            #將IsPaseBool設為True
            
            語音播放 = not 語音播放
            #改變語音播放狀態
            
            n=句子播放句數[-1]
            #將句子播放句數的最後一個元素設為n
            
            n2=單字播放個數[-1]
            #將單字播放個數的最後一個元素設為n2
            
            tmpBool = True
            
            tmpBool2 = True
            
            while pygame.mixer.music.get_busy and IsPaseBool == True:
                
                現在語音播放時間1 = pygame.mixer.music.get_pos()
                
                t0 = 暫停時間點[-1]
                
                if 現在語音播放時間1-暫停時間點[-1]>300 :
                    
                    現在語音播放時間1=min(現在語音播放時間1,t0)
                    
                if 現在語音播放時間1-t0<=300 :
                    
                    現在語音播放時間1=max(現在語音播放時間1,t0)
                    
                    暫停時間點.append(現在語音播放時間1)
                    
                if n<len(句子播放列表):
                    
                    文字顯示當n小於句子播放列表(現在語音播放時間1,n,tmpBool)
                    
                    tmpBool = False
                    
                    if 現在語音播放時間1>=int(句子播放列表[n][4]):
                    #假設現在語音播放時間大於等於現在語音播放時間
                    #代表此句子的語音內容已播放完畢
                        
                        n+=1
                        #則把n加一進入下一個句子的播放狀態
                        
                    tmpBool = True
                    
                if n == len(句子播放列表):
                #當n等於句子播放列表的長度時
                    
                    文字顯示當n等於句子播放列表()
                    
                    語音開始 = False
                    
                    語音播放 = False
                    
                    IsPaseBool = True
                    
                    break
                
                if n2<len(單字播放列表):
                #當n2小於單字播放列表時
                    
                    文字顯示當n2小於單字播放列表(現在語音播放時間1,n2,tmpBool2)
                    
                    tmpBool2 = False
                    
                    if 現在語音播放時間1>=int(單字播放列表[n2][4]):
                    #假設現在語音播放時間大於等於現在語音播放時間
                    #代表此單字的語音內容已播放完畢
                        
                        n2+=1
                        #則把n2加一進入下一個單字的播放狀態
                        
                    tmpBool2 = True
                    
                if n2 == len(單字播放列表):
                #當n2等於單字播放列表的長度時
                    
                    文字顯示區.tag_remove('found',單字播放列表[-1][1],
                    單字播放列表[-1][2])
                    #運用tag_remove()去除最後一個單字的顯示效果
                    
                if IsPaseBool ==False:
                #假設IsPaseBool等於False
                    
                    文字顯示區當IsPaseBool等於False(n,n2)
                    
                    break
                
    else:
        
        IsPaseBool = False
        #將IsPaseBool的值設為False
        
        pygame.mixer.music.pause()
        #用pygame.mixer.music.pause()將語音暫停
        
        語音播放狀態.append("F")
        
        del 暫停時間點[:]
        #將暫停時間點先清空
        
        現在語音播放時間 = pygame.mixer.music.get_pos()
        #取出暫停的時間點
        
        暫停時間點.append(現在語音播放時間)
        #將時間點存入暫停時間點
        
        語音播放 = not 語音播放
        #改變語音撥放的原始狀態
       
            
def 選擇文章():
    
    語音播放狀態.append("restart")
    
    pygame.mixer.quit()
    
    del 句子播放句數[:]
    
    del 單字播放個數[:]
    
    del 單字播放列表[:]
    
    del 句子播放列表[:]
    
    del 單字拼音[:]
    
    del 拼音句子[:]
    
    文章資料夾 = r'%s\%s'%(檔案路徑,"Output/article")
    #將絕對路徑做延長指向Input資料夾
    
    文字檔案所在的路徑 = askopenfilename(initialdir=文章資料夾)
    #用askopenfilename()取得被使用者所選取的文字檔的絕對路徑位置
    
    文字檔案名稱 = os.path.split(文字檔案所在的路徑)[1]
    #用os.path.split()取得路徑最後的文字檔案名稱
    
    名稱 = 文字檔案名稱.replace('.txt','')
    #去除文字檔的副檔名
    
    檔案文件 = open(文字檔案所在的路徑,'r',encoding="utf-8")
    #選擇檔案
    
    文章 = 檔案文件.read()
    #讀取檔案文件的文字內容
    
    檔案文件.close()
    #讀取完檔案文件的文字內容將其關閉
    
    文字顯示區.delete(1.0,END)
    #首先為了確保畫面中的文字顯示區為淨空的狀態 
    #因此再插入文章內容時必須先清空文字顯示區
    
    文字顯示區.tag_configure('big',font=('Verdana',10,'bold'))
    #設定插入文章的文字大小及字型
    
    文字顯示區.insert(1.0,文章,'big')
    #將文章的文字內容從文字顯示區的1.0起始位置開始插入
    
    製做句子播放列表(名稱)
    
    製做單字播放列表(名稱)
    
    閱讀的文章.append(名稱)
    print(名稱)
    
    pygame.mixer.pre_init(frequency=16000,channels=2,size=-16)
    #預設pygame.mixer的預設值
    
    pygame.mixer.init()
    #用上述的參數對pygame.mixer做初始畫
    
    pygame.mixer.music.load('./Output/mp3/'+名稱+".mp3")
    #用pygame.mixer.music.load讀入檔案

def 取得文章字(字串):
    """
    以一句句的單位句子為輸入進行切割，
     
    其結果為一個個單字或一串數字或單一
     
    字母或數字
    """
    字=字串.split()
     
    for 字母串 in 字:

        文章字.append(字母串)
        
def 新增文章():
    """
    運用tkinter.filedialog讓使用者可以藉由滑鼠點選的動作
    選取使用者所需要的文字檔(xxx.txt)並做文字檔內容的文字處理,
    google語音合成,mp3_to_wav,製作sentence_level_sbv檔,
    CguAlign_wj_01.CguAlign主程式做語音辨識產生單字的時間點,
    製作句子語音同步列表,製做單字語音同步列表
    """
    文字顯示區.delete(1.0,END)
    try:
        成功.append("t")
        
        取得標點符號()
    
        製造資料夾()
    
        del 去除標點符號的單位句子[:]

        del 去除標點符號的單位句子1[:]
    
        del 文章字[:]
    
        del 單位句子[:]
    
        del 單位句子中每個句子的檔案大小[:]
    
        桌面路徑=os.path.split(檔案路徑)[0]
    
        文字檔案所在的路徑 = askopenfilename(initialdir=桌面路徑)
        #用askopenfilename()取得被使用者所選取的文字檔的絕對路徑位置
    
        文字檔案名稱 = os.path.split(文字檔案所在的路徑)[1]
        #用os.path.split()取得路徑最後的文字檔案名稱
    
        名稱=文字檔案名稱.replace('.txt','')
        #去除文字檔的副檔名
    
        文章集.append(名稱)
        #將文字檔案的檔名加到文章集中
    
        檔案文件 = open(文字檔案所在的路徑,'r',encoding="utf-8")
        #選擇檔案
    
        文章= 檔案文件.read()
        #讀取檔案文件的文字內容
    
        檔案文件.close()
        #讀取完檔案文件的文字內容將其關閉
      
        文字顯示區.delete(1.0,END)
        #首先為了確保畫面中的文字顯示區為淨空的狀態 
        #因此再插入文章內容時必須先清空文字顯示區
    
        文字顯示區.tag_configure('big',font=('Verdana',10,'bold'))
        #設定插入文章的文字大小及字型
    
        文字顯示區.insert(1.0,文章,'big')
        #將文章的文字內容從文字顯示區的1.0起始位置開始插入
    
        文字處理(文章)
        
        
        for i in 單位句子:
        
            輸入 = str(i)
            
            取得文章字(輸入)
            
        google語音合成(名稱+'.mp3')
    
        wav語音檔長度=mp3_to_wav()
    
        製作sentence_level_sbv檔(wav語音檔長度)
  
        CguAlign_wj_01.CguAlign主程式(文章集[-1])
    
        句子 = 製作句子語音同步列表(文字顯示區)
    
        單字 = 製做單字語音同步列表(文字顯示區)
    
        句子單字語音同步列表 = 句子+"@@"+單字
    
        句子單字語音同步列表存取位置 =  r'%s\%s'%(檔案路徑,"Output/tlt")
        #將檔案路徑做延伸到原有資料夾下的單字語音同步列表資料夾
    
        句子單字語音同步列表名稱 = 文章集[-1]+".tlt"
        #依照使用者所點選檔案的檔名來命名
    
        完整路徑名稱 = os.path.join(句子單字語音同步列表存取位置,
        句子單字語音同步列表名稱)
        #將語音同步列表檔存取位置及語音同步列表名稱做相加產生完整路徑名稱
    
        句子單字語音同步列表檔案 = open(完整路徑名稱,'w',encoding="utf-8")
        #運用完整路徑名稱創造檔案並採用寫入的模式
    
        句子單字語音同步列表檔案.write(句子單字語音同步列表)
        #將句子語音同步列表字串寫入句子語音同步列表檔案
    
        句子單字語音同步列表檔案.close()
        #寫入後將檔案關閉
    
        寫出路徑 = os.path.join('Output/article',文字檔案名稱)
    
        檔案文件 = open(寫出路徑,'w',encoding="utf-8")
    
        檔案文件.write(文章)
    
        檔案文件.close()
    
        刪除多餘資料夾(名稱)
    
        del 標點符號編碼[:]
    except:
        
        成功.append("f")
        
        文字顯示區.delete(1.0,END)

        文字顯示區.tag_configure('big',font=('Verdana',20,'bold'))
        #設定插入文章的文字大小及字型

        文字顯示區.insert(1.0,"抱歉!文章不能處理",'big')
        #將文章的文字內容從文字顯示區的1.0起始位置開始插入

        check()        
        
def 中文文字處理(i):
    
    i = i.replace("\n\n","\n")
    #將連續兩個換行符號替換成一個換行符號

    換行符號 ='\n'
    
    換行符號位置 = 尋找符號位置(i,換行符號)
    #搜尋換行符號在文章string中的index

    檢查符號=["。","、","!","?",")","」"
             ,"』","；","，","】","》","〉"
             ,"﹃","﹂","]","）"," – ","："]
    #搜尋以下符號

    檢查符號2 = ["(","【","《","〈",
             "「","『","﹄","﹁","[","（"]

    切割位置 = []
    #創立切割位置list

    for 符號 in 檢查符號:

        檢查符號位置 = 尋找符號位置(i,符號)
        #取得文章中所有檢察符號的index()

        切割位置.extend(檢查符號位置)
        #並加入切割為誌中

    for 符號 in 檢查符號2:

        檢查符號位置2 = 尋找符號位置(i,符號)
        
        檢查符號位置3 = []
        if len(檢查符號位置2)!=0:
            for q in 檢查符號位置2:

                t = int(q)-1
                if t not in 切割位置:
                    
                    切割位置.append(t)

    for k in 換行符號位置:

        if int(k)-1 not in 切割位置:
        #將換行符號減一做檢查如果在則標示所有句
        #子的結束位置以標記如果不在代表有的句子
        #結尾是沒有標點符號或是其他特殊服號

            切割位置.append(int(k)-1)
            #將沒出現過的位置加入切割位置
    
    切割位置1=sorted(切割位置)
    #用sorted將切割位置內的元素由小到大依序排列

    刪除點=[]

    for a in range(0,len(切割位置1)-1,1):
    #用迴圈檢察切割位置       

        if int(切割位置1[a+1])-int(切割位置1[a])==1:
        #如果彼此相檢結果為1表示句子結尾有符號相連       

            刪除點.append(int(切割位置1[a]))
            #相連時紀錄最小者於刪除點

    for 點 in 刪除點:
    #用刪除點去除切割位置1內相鄰最小者

        if 點 in 切割位置1:

            切割位置1.remove(點)

    句子組 = []

    起始 = int(0)

    for s in range(0,len(切割位置1),1):

        結束 = int(切割位置1[s])+1

        句子 = i[起始:結束]

        句子 = 句子.strip()

        單位句子.append(句子)

        起始 = 結束

    
    for k in 單位句子:

        if len(k)==0:

            單位句子.remove(k)
    for g in 單位句子:

        去除符號 = 去除標點符號(str(g))

        if len(去除符號)==0:

            單位句子.remove(g)

    for l in range(0,len(單位句子),1):
    #用for迴圈去除每個單位句子內的所有標點符號並將其加入去除標點符號的單位句子

        輸入 = 單位句子[l]

        空白 =""

        for 字元 in 輸入:

            if str(ord(字元)) not in 標點符號編碼:

                空白 = 空白+字元
        
        
        去除標點符號的單位句子.append(空白)


                
                     
    

                
def google中文語音合成(檔案名稱):
    
    GOOGLE_TTS_URL ='http://translate.google.com/translate_tts'
    #設定googletts的網址
    
    文字語言 = []
    #宣告一個空陣列名為文字語言
    
    for i in range(0,len(單位句子),1):
    #用for迴圈將單位句子中的每一個元素依序
    #加入文字語言並在每個元素後加上其語言種類
        
        語言 = "zh-TW"
        #設定語言種類為''zh-TW'中文
        
        句子 = 單位句子[i]
        #設定句子為單位句子
        
        文字語言+=[(句子,語言)]
        #最後依序加入文字語言中
        
    語音檔存取位置 =  r'%s\%s'%(檔案路徑,"Output/mp3")
    
    語音檔案名稱 = 檔案名稱
    
    完整名稱 = os.path.join(語音檔存取位置,檔案名稱)
    
    語音檔案 = open(完整名稱,'wb')
    #開啟一個新的檔案名為語音檔案用來存取語音內容
    
    for idx,句子語言 in enumerate(文字語言):
    #用for迴圈取得每句話的idx
        
        句子,語言 =  句子語言
        #將文字語言內的句子和語言分別傳入句子,語言
        
        payload = { 'ie':'utf8',
                    'tk':'308912',
                    'client':'t',
                    'tl':語言,
                    'q':句子,
                    'total':len(文字語言),
                    'idx':idx,
                    'textlen':len(句子)}
        #pyload是將文章傳給google做語音合成所需具備的
        #參數其含有'ie':(編碼的格式)'tl':(合成所需的語言)
        #'q':(每次要合成的句子)'total':(共有多少句子需做語音合成)
        #'idx':(每個句子的檔案大小)'textlen':(每次要合成的句子長度)
        
        try:
            
            暫存檔案 = requests.get(GOOGLE_TTS_URL,params=payload)
            #用requests.get()對google送出請求並取得每次要合成語音的
            #語音內容並存入暫存檔案中
            
            每句和成句子的檔案大小 = len(暫存檔案.content)
            #用len取得暫存檔案.content的長度即為每句和成句子的檔案大小
            
            語音檔案.write(暫存檔案.content)
            #將所有的暫存檔案都寫入語音檔案
            
            單位句子中每個句子的檔案大小.append(每句和成句子的檔案大小)
            #將每句和成句子的檔案大小加入單位句子中每個句子的檔案大小的
            #這個陣列中
            
        except Exception as e:
            
            raise
        
    語音檔案.close()
    #當所有句子的語音內容都寫入時將語音檔案關閉

def 數字轉中文拼音(k):

    數字 = ["0","1","2","3","4","5","6","7","8","9"]
        
    數字拼音 = ["ling","yi","er","san","si","wu","liu","qi","ba","jiu"]

    查詢指標 = 數字.index(k)

    單字拼音.append(數字拼音[查詢指標])

def 取得文章中每個單字的拼音( ):
    
    中文拼音對照表檔案 = open("中文拼音對照表.txt","r",encoding = "utf-8")
    
    中文拼音對照表內容 = 中文拼音對照表檔案.read()
    
    中文拼音對照表 = 中文拼音對照表內容.split("\n")
    
    中文拼音對照表檔案.close()
    
    for i in range(0,len(去除標點符號的單位句子),1):
        
        輸入句子 = str(去除標點符號的單位句子[i])
        
        for 字 in 輸入句子:
            
            文章字.append(字)

            if str(字).isdigit():
                
                數字轉中文拼音(字)

            else:
            
                索引 = str(ord(str(字)))
                #用ord取得每個字的unicode編碼
            
                for a in 中文拼音對照表:
                
                    if 索引 in str(a):
                    
                        索引內容 = str(a).split("||")
                    
                        文字拼音 = 索引內容[2]
                        #利用unicode從中文拼音對照表中取出拼音
                    
                        單字拼音.append(文字拼音)
    
def 製做中文sentence_levl_sbv檔(j):
    """
    這個function的作用是將去除標點符號的單位句子中的每個句子,
    以字為單位用google取得的單字拼音做替換
    並將所有非英文注音的符號做替換,形成一句句由拼音構成的句子。
    """
    
    for k in range(0,len(去除標點符號的單位句子),1):
        
        輸入句子 = 去除標點符號的單位句子[k]
        
        for 字 in 輸入句子:
            
            if 字.isalpha()or 字.isdigit():
                
                拼音位置 = 文章字.index(str(字))
                
                輸入句子 = str(輸入句子).replace(str(字),
                          str(單字拼音[拼音位置])+" ")
        print(輸入句子)      
        拼音句子.append(輸入句子)
        
    檔案大小 = sum(單位句子中每個句子的檔案大小)
    #用sum將單位句子中每個句子的檔案大小中所有的元素做相加取得檔案大小
    
    開始時間 = 0.0
    #設定開始時間為0.0
    
    sbv寫入內容 = ""
    #設定sbv寫入內容
    
    for i in range(0,len(單位句子中每個句子的檔案大小),1):
    #運用for迴圈求取句子播放時的開始時間及結束時間
        
        開始時間_小時 = int(開始時間/3600)
        #將時間做換算取出開始時間_小時
        
        開始時間_分鐘 = int((開始時間%3600)/60)
        #將時間做換算取出開始時間_分鐘
        
        開始時間_秒 = 開始時間%60
        #將時間做換算取出開始時間_秒
        
        句子檔案 = 單位句子中每個句子的檔案大小[0:i+1]
        #取得所有句子累加的大小
        
        句子的時間百分比 = sum(句子檔案)/檔案大小
        #求出句子檔案在檔案大小中所佔的比例存入名為句子的時間百分比
        
        結束時間=(j*句子的時間百分比)/1000
        #運用mp3_to_wav所取出的總共秒數乘上句子的時間百分比取得句子的時間長度
        
        結束時間_小時 = int(結束時間/3600)
        #將時間做換算取出結束時間_小時
        
        結束時間_分鐘 = int((結束時間%3600)/60)
        #將時間做換算取出結束時間_分鐘
        
        結束時間_秒 = 結束時間%60
        #將時間做換算取出結束時間_秒
        
        sbv寫入內容+="{0}:{1}:{2:f},{3}:{4}:{5:f}\n".format(開始時間_小時
            ,開始時間_分鐘,開始時間_秒,結束時間_小時,結束時間_分鐘,結束時間_秒)
        #將開始時間_小時,開始時間_分鐘,開始時間_秒,
        #結束時間_小時,結束時間_分鐘,結束時間_秒寫入sbv寫入內容
        
        sbv寫入內容+=str(拼音句子[i].replace("\ufeff","")).lower()+"\n\n"
        
        開始時間 = 結束時間
        
    路徑 = "./cgualign_lite/Input/"
    
    sbv檔案= open(str(路徑)+文章集[-1]+".sbv","w+",encoding="utf-8")
    #以點選文章的名稱做檔案名稱另存sbv檔於sentence_level_SBV資料夾中
    
    sbv檔案.write(sbv寫入內容)
    #將sbv寫入內容寫入sbv檔案
    
    sbv檔案.close()
    #將sbv檔案關閉
    
def 製作中文句子語音同步列表(j):
    """
    運用從cgulign_lite中Input內的sbv檔來製作句子語音同步用的資料表
    其內容為(句子,畫面中句子的起始位置,畫面中句子的結束位置,
    句子在wav檔中的播放起始時間,句子在wav檔中的播放結束時間)
    input:j 為文字顯示區
    """
    
    路徑 = "./cgualign_lite/Input/"
    
    sentence_level_sbv = open(str(路徑)+文章集[-1]+".sbv","r",encoding='utf8')
    #先取出cgulign_lite中Input內的sbv檔
    
    sentence_level_sbv內容 = sentence_level_sbv.read()
    #將sbv檔用read()做讀取
    
    sentence_level_sbv.close()
    
    sentence_level_sbv內容 = sentence_level_sbv內容.replace('\n\n','\n')
    #先將兩個換行符號做替換,換成一個換行符號用來消除sbv檔中的空行
    
    sentence_level_sbv內容列表 = sentence_level_sbv內容.split('\n')
    #接著以換行符號做切割,分割出句子和時間其時間包含起始時間和結束時間
    
    時間列表 = []
    #創造時間列表用來存取時間
    
    for i in range(0,len(sentence_level_sbv內容列表),1):
    #用for迴圈分別將句子存入句子列表,將時間存入時間列表
        
        if i%2==0 and len(sentence_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後時間的部分在list中的單數元素
            
            時間列表.append(sentence_level_sbv內容列表[i])
            #所以將單數元素存入時間列表
            
    時間字串 = ""
    #創造時間字串用來連接所有時間列表內的所有元素
    
    for i in range(0,len(時間列表),1):
    #用for迴圈依序將所有在時間列表內的元素做銜接
        
        時間字串+=時間列表[i]+","
        #並在元素之間加上逗號","
        
    時間列表2 =時間字串.split(',')
    #最後用逗號做切割產生時間列表
    
    開始時間 = []
    #創造開始時間用來存取每個句子在播放時的起始時間
    
    結束時間 = []
    #創造結束時間用來存取每個句子在播放時的結束時間
    
    暫存 = []
    #創造暫存用來存取句子語音同步資料字串
    
    for i in range(0,len(時間列表2),1):
    #用for迴圈分別將句子在播放時的起始時間存入開始時間,
    #句子在播放時的結束時間存入結束時間
        
        if i%2==0 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #句子在播放時的起始時間在時間列表2這個list的單數元素
            
            開始時間.append(時間列表2[i])
            #將句子在播放時的起始時間存入開始時間
            
        if i%2==1 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #句子在播放時的結束時間在時間列表2這個list的偶數元素
            
            結束時間.append(時間列表2[i])
            #將句子在播放時的結束時間存入結束時間
            
    句子起始位置='1.0'
    #設定句子起始位置為'1.0'其1為列數0為行數
    
    for i in range(0,len(開始時間),1):
    #設立for迴圈將每個句子在畫面中的位置找出來
        
        句子 = 單位句子[i]
        #依序將句子列表內的元素存入名為句子的變數
        
        句子起始位置 = 文字顯示區.search(句子,句子起始位置)
        #運用文字顯示區.search找出每個句子在文字顯示區的開始位置
        
        if not 句子起始位置:
        #設定判斷式假如找不到句子起始位置則跳出
            
            break
        
        句子起始位置和句子長度 = '%s+%dc' %(句子起始位置,len(句子))
        
        句子結束位置 = 文字顯示區.index(句子起始位置和句子長度)
        #將句子起始位置加上句子本身長度來計算出句子結束位置
        
        開始_時_分_秒 = 開始時間[i].split(':')
        #將開始時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        句子開始時間 = (int(開始_時_分_秒[0])*3600000
                      +int(開始_時_分_秒[1])*60000
                      +int(float(開始_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        結束_時_分_秒 = 結束時間[i].split(':')
        #將結束時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        句子結束時間 = (int(結束_時_分_秒[0])*3600000
                      +int(結束_時_分_秒[1])*60000
                      +int(float(結束_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        句子語音同步資料字串 = (str(句子)+"||"
                             +str(句子起始位置)+"||"
                             +str(句子結束位置)+"||"
                             +str(句子開始時間)+"||"
                             +str(句子結束時間)+"\n")
        #將所有句子語音同步資料轉為字串存入名為句子語音同步資料字串的變數
        
        暫存.append(句子語音同步資料字串)
        #將所有句子語音同步資料字串依序加入暫存
        
        句子起始位置 = 句子結束位置
        #將句子結束位置設為句子起始位置準備找尋下一個句子的句子結束位置
        
    句子語音同步列表字串 = ''.join(i for i in 暫存)
    #用for迴圈將暫存中的句子語音同步資料字串依序做銜接
    
    del 暫存[:]
    
    del 結束時間[:]
    
    del 開始時間[:]
    
    del 時間列表[:]
    
    return 句子語音同步列表字串

def 製做中文單字語音同步列表(j):
    """
    運用從cgulign_lite中Output內的切到字的sbv檔資料夾中的
    sbv檔來製作單字語音同步用的資料表,並運用拼音對照列表將拼音
    轉換成單字其內容為(單字,畫面中單字的起始位置,畫面中單字的結束位置,
    單字在wav檔中的播放起始時間,單字在wav檔中的播放結束時間)
    input:j 為文字顯示區
    """
    
    路徑 = "./cgualign_lite/Output/切到字的sbv檔/"
    
    word_level_sbv = open(str(路徑)+文章集[-1]+".sbv","r",encoding='utf8')
    #先取出cgulign_lite中Output內的切到字的sbv檔資料夾中的sbv檔
    
    word_level_sbv內容 = word_level_sbv.read()
    #將sbv檔用read()做讀取
    
    word_level_sbv.close()
    
    word_level_sbv內容 = word_level_sbv內容.replace('\n\n','\n')
    #先將兩個換行符號做替換,換成一個換行符號用來消除sbv檔中的空行
    
    word_level_sbv內容列表 = word_level_sbv內容.split('\n')
    #接著以換行符號做切割,分割出單字和時間其時間包含起始時間和結束時間
    
    時間列表 = []
    #創造時間列表用來存取時間
    
    單字列表 = []
    #創造單字列表用來存取單字
    
    for i in range(0,len(word_level_sbv內容列表),1):
    #用for迴圈分別將單字存入單字列表,將時間存入時間列表
        
        if i%2==0 and len(word_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後時間的部分在list中的單數元素
            
            時間列表.append(word_level_sbv內容列表[i])
            #所以將單數元素存入時間列表
            
        if i%2==1 and len(word_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後單字的部分在list中的偶數元素
            
            單字列表.append(word_level_sbv內容列表[i])
            #所以將偶數元素存入單字列表
            
    時間字串 = ""
    #創造時間字串用來連接所有時間列表內的所有元素
    
    for i in range(0,len(時間列表),1):
    #用for迴圈依序將所有在時間列表內的元素做銜接
        
        時間字串+=時間列表[i]+","
        #並在元素之間加上逗號","
        
    時間列表2 =時間字串.split(',')
    #最後用逗號做切割產生時間列表
    
    開始時間 = []
    #創造開始時間用來存取每個單字在播放時的起始時間
    
    結束時間 = []
    #創造結束時間用來存取每個單字在播放時的結束時間
    
    暫存 = []
    #創造暫存用來存取單字語音同步資料字串
    
    for i in range(0,len(時間列表2),1):
    #用for迴圈分別將單字在播放時的起始時間存入開始時間,
    #單字在播放時的結束時間存入結束時間
        
        if i%2==0 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #單字在播放時的起始時間在時間列表2這個list的單數元素
            
            開始時間.append(時間列表2[i])
            #將單字在播放時的起始時間存入開始時間
            
        if i%2==1 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #單字在播放時的結束時間在時間列表2這個list的偶數元素
            
            結束時間.append(時間列表2[i])
            #將單字在播放時的結束時間存入結束時間
            
    單字起始位置='1.0'
    #設定單字起始位置為'1.0'其1為列數0為行數
    
    for i in range(0,len(開始時間),1):
    #設立for迴圈將每個單字在畫面中的位置找出來
        
        單字= 文章字[i]
        #依序將單字列表內的元素存入名為單字的變數
        
        單字起始位置 = 文字顯示區.search(單字,單字起始位置)
        #運用文字顯示區.search找出每個單字在文字顯示區的開始位置
        
        if not 單字起始位置:
        #設定判斷式假如找不到單字起始位置則跳出
            
            break
        
        單字起始位置和單字長度 = '%s+%dc' %(單字起始位置,len(單字))
        
        單字結束位置 = 文字顯示區.index(單字起始位置和單字長度)
        #將單字起始位置加上單字本身長度來計算出單字結束位置
        
        開始_時_分_秒 = 開始時間[i].split(':')
        #將開始時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        單字開始時間 = (int(開始_時_分_秒[0])*3600000
                      +int(開始_時_分_秒[1])*60000
                      +int(float(開始_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        結束_時_分_秒 = 結束時間[i].split(':')
        #將結束時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        單字結束時間 = (int(結束_時_分_秒[0])*3600000
                      +int(結束_時_分_秒[1])*60000
                      +int(float(結束_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        單字語音同步資料字串 = (str(單字)+"||"
                             +str(單字起始位置)+"||"
                             +str(單字結束位置)+"||"
                             +str(單字開始時間)+"||"
                             +str(單字結束時間)+"\n")
        #將所有單字語音同步資料轉為字串存入名為單字語音同步資料字串的變數
        
        暫存.append(單字語音同步資料字串)
        #將所有句子語音同步資料字串依序加入暫存
        
        單字起始位置 = 單字結束位置
        #將單字結束位置設為單字起始位置準備找尋下一個單字的單字結束位置
        
    單字語音同步列表字串 = ''.join(i for i in 暫存)
    #用for迴圈將暫存中的單字語音同步資料字串依序做銜接
    
    del 暫存[:]
    
    del 結束時間[:]
    
    del 開始時間[:]
    
    del 單字列表[:]
    
    del 時間列表[:]
    
    del 單字拼音[:]
    
    return 單字語音同步列表字串

def 日文文字處理(i):
    
    i = i.replace('\n','')
    #去除換行符號
    
    i = i.replace(",",",@")
    
    i = i.replace("、","、@")
    
    i = i.replace("。","。@")
    
    i = i.replace("「","@「")
    
    i = i.replace("」","」@")
    
    句子組 = i.split("@")
    
    for i in 句子組:
        
        i = i.strip()
        
        if len(i)>0:
            
            單位句子.append(i)
            
    del 句子組[:]
    
    for l in range(0,len(單位句子),1):
    #用for迴圈去除每個單位句子內的所有標點符號並將其加入去除標點符號的單位句子
        
        輸入 = 單位句子[l]
        
        空白 =""
        
        for 字元 in 輸入:
            
            if str(ord(字元)) not in 標點符號編碼:
                
                空白 = 空白+字元
                
        去除標點符號的單位句子.append(空白)
        
    送給mecab處理的檔案 = open("mecab_process.txt","w",encoding="utf-8")
    #創一個名為mecab_process.txt用來寫入所有去除標點符號的單位句子
    
    mecab檔案寫入內容 = ""
    #設定mecab檔案寫入內容
    
    for k in range(0,len(去除標點符號的單位句子),1):
    #用for迴圈將所有去除標點符號的單位句子寫入
        
        mecab檔案寫入內容+=去除標點符號的單位句子[k]+"\n"
        
    送給mecab處理的檔案.write(mecab檔案寫入內容)
    
    送給mecab處理的檔案.close()
    
def mecab日文斷詞():
    """
    用dos的方式呼叫mecab將mecab_process.txt的內容交由mecab
    做日文的斷詞
    """
    
    選擇的檔案 = "mecab_process.txt"
    
    輸出的檔案 = "mecab_processed.txt"
    
    cmdDos = "mecab -o {0} {1}".format(輸出的檔案,選擇的檔案)
    
    os.system(cmdDos)

def 取得羅馬拼音的日文斷詞():
    """
    將mecab處理後的結果選取非記號的日文原始詞及拼音,並將拼音經由romkan做
    日文拼音轉羅馬拼音的轉換
    """
    
    讀取檔案 = open("mecab_processed.txt","r",encoding="utf-8")
    #開啟經由mecab處理過後的文章結果
    
    讀取檔案內容 = 讀取檔案.read()
    #讀取經由mecab處理過後的文章結果
    
    讀取檔案.close()
    
    os.remove("mecab_processed.txt")
    
    os.remove("mecab_process.txt")
    
    斷詞內容 = 讀取檔案內容.split("\n")
    #以換行符號為切割點進行切割
    
    for a in 斷詞內容:
    #用for迴圈取出日文原始詞及日文拼音並以romkan將日文拼音轉為羅馬拼音
        
        b = a.split("\t")
        
        if len(b)==2:
            
            字串 = str(b[1])
            
            if not 字串.startswith("記号"):
                
                日文原始詞 = b[0]
                
                文章字.append(日文原始詞)
                
                日文拼音 = b[1].split(",")[-1]
                
                羅馬拼音 = romkan.to_kunrei(日文拼音)
                
                for i in range(0,len(羅馬拼音),1):
                #由於經由romkan轉換後的拼音還是含有特殊符號(',-)
                #因此針對此兩種符號進行處理
                    
                    if 羅馬拼音[i] =="'":
                    #假設符號為"'"
                        
                        羅馬拼音 = 羅馬拼音.replace(羅馬拼音[i],羅馬拼音[i-1])
                        #則將此替換成前一個羅馬拼音
                        
                    if 羅馬拼音[i] =="-":
                    #假設符號為"-"
                        
                        羅馬拼音 = 羅馬拼音.replace(羅馬拼音[i],羅馬拼音[i-1])
                        #則將此符號替換成前一個羅馬拼音
                        
                單字拼音.append(羅馬拼音)
                #並將所有單字的拼音存於單字拼音
                
def 產生羅馬拼音的單位句子():
    """
    運用所有的單字拼音將其組成每一個單位句子的拼音
    """
    
    for a in 去除標點符號的單位句子:
        
        if len(a)==0:
            
            去除標點符號的單位句子.remove(a)
            
    句子拼音內容 = []
    
    k =0
    
    for i in range(0,len(去除標點符號的單位句子),1):
        
        輸入 = str(去除標點符號的單位句子[i])
        #輸入去除去除標點符號的單位句子
        
        輸入句長 = len(輸入)
        #計算其句子長度
        
        while 輸入句長!=0:
            
            輸入句長 = 輸入句長-len(文章字[k])
            #將句子長度依序剪去文章字裡的每個單位的單位長度
            
            if 單字拼音[k] == "*":
                
                單字拼音[k] = 文章字[k]
                
                if ord(單字拼音[k])>=19968 and ord(單字拼音[k])<=40868:
                    
                    字典 = "中文拼音對照表.txt"
                    
                    中文拼音對照表檔案 = open(str(字典),"r",encoding = "utf-8")
                    
                    中文拼音對照表內容 = 中文拼音對照表檔案.read()
                    
                    中文拼音對照表 = 中文拼音對照表內容.split("\n")
                    
                    中文拼音對照表檔案.close()
                    
                    索引 = str(ord(str(單字拼音[k])))
                    
                    for a in 中文拼音對照表:
                        
                        if 索引 in str(a):
                            
                            索引內容 = str(a).split("||")
                            
                            文字拼音 = 索引內容[2]
                            
                            單字拼音[k] = 文字拼音
                            
            句子拼音內容.append(單字拼音[k])
            #並將減去的單位所代表的拼音加入句子拼音內容
            
            k = k+1
            #當加入後則再用下一個文章字中的單位
            
            if 輸入句長==0:
            #當輸入句長被減為0則代表句子中的每個詞或字的拼音已全
            #被加入句子拼音內容中
                
                句子拼音 = ""
                
                for 拼音 in 句子拼音內容:
                #再運用for迴圈將句子拼音內容中的所有拼音依序銜接產生句子拼音
                    
                    句子拼音 = 句子拼音+拼音+" "
                  
                拼音句子.append(句子拼音)
                
                del 句子拼音內容[:]
                
                break
        
def google日文語音合成(檔案名稱):
    
    GOOGLE_TTS_URL = 'http://translate.google.com/translate_tts'
    #設定googletts的網址
    
    文字語言 = []
    #宣告一個空陣列名為文字語言
    
    for i in range(0,len(單位句子),1):
    #用for迴圈將單位句子中的每一個元素依序
    #加入文字語言並在每個元素後加上其語言種類
        
        語言 = "ja"
        #設定語言種類為'ja'日文
        
        句子 = 單位句子[i]
        #設定句子為單位句子
        
        文字語言+=[(句子,語言)]
        #最後依序加入文字語言中
        
    語音檔存取位置 =  r'%s\%s'%(檔案路徑,"Output/mp3")
    
    語音檔案名稱 = 檔案名稱
    
    完整名稱 = os.path.join(語音檔存取位置,檔案名稱)
    
    語音檔案 = open(完整名稱,'wb')
    #開啟一個新的檔案名為語音檔案用來存取語音內容
    
    for idx,句子語言 in enumerate(文字語言):
    #用for迴圈取得每句話的idx
        
        句子,語言 =  句子語言
        #將文字語言內的句子和語言分別傳入句子,語言
        
        payload = { 'ie':'utf8',
                    'tk':'308912',
                    'client':'t',
                    'tl':語言,
                    'q':句子,
                    'total':len(文字語言),
                    'idx':idx,
                    'textlen':len(句子)}
        #pyload是將文章傳給google做語音合成所需具備的
        #參數其含有'ie':(編碼的格式)'tl':(合成所需的語言)
        #'q':(每次要合成的句子)'total':(共有多少句子需做語音合成)
        #'idx':(每個句子的檔案大小)'textlen':(每次要合成的句子長度)
        
        try:
            
            暫存檔案 = requests.get(GOOGLE_TTS_URL,params=payload)
            #用requests.get()對google送出請求並取得每次要合成語音的
            #語音內容並存入暫存檔案中
            
            每句和成句子的檔案大小 = len(暫存檔案.content)
            #用len取得暫存檔案.content的長度即為每句和成句子的檔案大小
            
            語音檔案.write(暫存檔案.content)
            #將所有的暫存檔案都寫入語音檔案
            
            單位句子中每個句子的檔案大小.append(每句和成句子的檔案大小)
            #將每句和成句子的檔案大小加入單位句子中每個句子的檔案大小的
            #這個陣列中
            
        except Exception as e:
            
            raise
        
    語音檔案.close()
    #當所有句子的語音內容都寫入時將語音檔案關閉
   
def 製做日文sentence_level_sbv檔(j):
    """
    運用拼音句子中的句子跟mp3_to_wav所取出的總共秒數
    乘上單位句子中每個句子的檔案大小在語音檔案大小所占的比例
    來求得每個句子的時間長來求得每個句子在播放時的開始時間及結束時間
    input(j):j代表wav語音的時間長度
    """
    
    檔案大小 = sum(單位句子中每個句子的檔案大小)
    #用sum將單位句子中每個句子的檔案大小中所有的元素做相加取得檔案大小
    
    開始時間 = 0.0
    #設定開始時間為0.0
    
    sbv寫入內容 = ""
    #設定sbv寫入內容
    
    for i in range(0,len(單位句子中每個句子的檔案大小),1):
    #運用for迴圈求取句子播放時的開始時間及結束時間
        
        開始時間_小時 = int(開始時間/3600)
        #將時間做換算取出開始時間_小時
        
        開始時間_分鐘 = int((開始時間%3600)/60)
        #將時間做換算取出開始時間_分鐘
        
        開始時間_秒 = 開始時間%60
        #將時間做換算取出開始時間_秒
        
        句子檔案 = 單位句子中每個句子的檔案大小[0:i+1]
        #取得所有句子累加的大小
        
        句子的時間百分比 = sum(句子檔案)/檔案大小
        #求出句子檔案在檔案大小中所佔的比例存入名為句子的時間百分比
        
        結束時間=(j*句子的時間百分比)/1000
        #運用mp3_to_wav所取出的總共秒數乘上句子的時間百分比取得句子的時間長度
        
        結束時間_小時 = int(結束時間/3600)
        #將時間做換算取出結束時間_小時
        
        結束時間_分鐘 = int((結束時間%3600)/60)
        #將時間做換算取出結束時間_分鐘
        
        結束時間_秒 = 結束時間%60
        #將時間做換算取出結束時間_秒
        
        sbv寫入內容+="{0}:{1}:{2:f},{3}:{4}:{5:f}\n".format(開始時間_小時,
        開始時間_分鐘,開始時間_秒,結束時間_小時,結束時間_分鐘,結束時間_秒)
        #將開始時間_小時,開始時間_分鐘,開始時間_秒,結束時間_小時,
        #結束時間_分鐘,結束時間_秒寫入sbv寫入內容
        
        sbv寫入內容+=拼音句子[i]+"\n\n"
        
        開始時間 = 結束時間
        
    路徑 = "./cgualign_lite/Input/"
    
    sbv檔案= open(str(路徑)+文章集[-1]+".sbv","w+",encoding="utf-8")
    #以點選文章的名稱做檔案名稱另存sbv檔於sentence_level_SBV資料夾中
    
    sbv檔案.write(sbv寫入內容)
    #將sbv寫入內容寫入sbv檔案
    
    sbv檔案.close()
    #將sbv檔案關閉

def 製作日文句子語音同步列表(j):
    """
    運用從cgulign_lite中Input內的sbv檔來製作句子語音同步用的資料表
    其內容為(句子,畫面中句子的起始位置,畫面中句子的結束位置,
    句子在wav檔中的播放起始時間,句子在wav檔中的播放結束時間)
    input:j 為文字顯示區
    """
    
    路徑 = "./cgualign_lite/Input/"
    
    sentence_level_sbv = open(str(路徑)+文章集[-1]+".sbv","r",encoding='utf8')
    #先取出cgulign_lite中Input內的sbv檔
    
    sentence_level_sbv內容 = sentence_level_sbv.read()
    #將sbv檔用read()做讀取
    
    sentence_level_sbv.close()
    
    sentence_level_sbv內容 = sentence_level_sbv內容.replace('\n\n','\n')
    #先將兩個換行符號做替換,換成一個換行符號用來消除sbv檔中的空行
    
    sentence_level_sbv內容列表 = sentence_level_sbv內容.split('\n')
    #接著以換行符號做切割,分割出句子和時間其時間包含起始時間和結束時間
    
    時間列表 = []
    #創造時間列表用來存取時間
    
    for i in range(0,len(sentence_level_sbv內容列表),1):
    #用for迴圈分別將句子存入句子列表,將時間存入時間列表
        
        if i%2==0 and len(sentence_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後時間的部分在list中的單數元素
            
            時間列表.append(sentence_level_sbv內容列表[i])
            #所以將單數元素存入時間列表
            
    時間字串 = ""
    #創造時間字串用來連接所有時間列表內的所有元素
    
    for i in range(0,len(時間列表),1):
    #用for迴圈依序將所有在時間列表內的元素做銜接
        
        時間字串+=時間列表[i]+","
        #並在元素之間加上逗號","
        
    時間列表2 =時間字串.split(',')
    #最後用逗號做切割產生時間列表
    
    開始時間 = []
    #創造開始時間用來存取每個句子在播放時的起始時間
    
    結束時間 = []
    #創造結束時間用來存取每個句子在播放時的結束時間
    
    暫存 = []
    #創造暫存用來存取句子語音同步資料字串
    
    for i in range(0,len(時間列表2),1):
    #用for迴圈分別將句子在播放時的起始時間存入開始時間,
    #句子在播放時的結束時間存入結束時間
        
        if i%2==0 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #句子在播放時的起始時間在時間列表2這個list的單數元素
            
            開始時間.append(時間列表2[i])
            #將句子在播放時的起始時間存入開始時間
            
        if i%2==1 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #句子在播放時的結束時間在時間列表2這個list的偶數元素
            
            結束時間.append(時間列表2[i])
            #將句子在播放時的結束時間存入結束時間
            
    句子起始位置='1.0'
    #設定句子起始位置為'1.0'其1為列數0為行數
    
    for i in range(0,len(開始時間),1):
    #設立for迴圈將每個句子在畫面中的位置找出來
        
        句子 = 單位句子[i]
        #依序將句子列表內的元素存入名為句子的變數
        
        句子起始位置 = 文字顯示區.search(句子,句子起始位置)
        #運用文字顯示區.search找出每個句子在文字顯示區的開始位置
        
        if not 句子起始位置:
        #設定判斷式假如找不到句子起始位置則跳出
            
            break
        
        句子起始位置和句子長度 = '%s+%dc' %(句子起始位置,len(句子))
        
        句子結束位置 = 文字顯示區.index(句子起始位置和句子長度)
        #將句子起始位置加上句子本身長度來計算出句子結束位置
        
        開始_時_分_秒 = 開始時間[i].split(':')
        #將開始時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        句子開始時間 = (int(開始_時_分_秒[0])*3600000
                      +int(開始_時_分_秒[1])*60000
                      +int(float(開始_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        結束_時_分_秒 = 結束時間[i].split(':')
        #將結束時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        句子結束時間 = (int(結束_時_分_秒[0])*3600000
                      +int(結束_時_分_秒[1])*60000
                      +int(float(結束_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        句子語音同步資料字串 = (str(句子)+"||"
                             +str(句子起始位置)+"||"
                             +str(句子結束位置)+"||"
                             +str(句子開始時間)+"||"
                             +str(句子結束時間)+"\n")
        #將所有句子語音同步資料轉為字串存入名為句子語音同步資料字串的變數
        
        暫存.append(句子語音同步資料字串)
        #將所有句子語音同步資料字串依序加入暫存
        
        句子起始位置 = 句子結束位置
        #將句子結束位置設為句子起始位置準備找尋下一個句子的句子結束位置
        
    句子語音同步列表字串 = ''.join(i for i in 暫存)
    #用for迴圈將暫存中的句子語音同步資料字串依序做銜接
    
    del 暫存[:]
    
    del 結束時間[:]
    
    del 開始時間[:]
    
    del 時間列表[:]
    
    return 句子語音同步列表字串

def 製做日文單字語音同步列表(j):
    """
    運用從cgulign_lite中Output內的切到字的sbv檔資料夾中的
    sbv檔來製作單字語音同步用的資料表,並運用拼音對照列表將拼音
    轉換成單字其內容為(單字,畫面中單字的起始位置,畫面中單字的結束位置,
    單字在wav檔中的播放起始時間,單字在wav檔中的播放結束時間)
    input:j 為文字顯示區
    """
    
    路徑 = "./cgualign_lite/Output/切到字的sbv檔/"
    
    word_level_sbv = open(str(路徑)+文章集[-1]+".sbv","r",encoding='utf8')
    #先取出cgulign_lite中Output內的切到字的sbv檔資料夾中的sbv檔
    
    word_level_sbv內容 = word_level_sbv.read()
    #將sbv檔用read()做讀取
    
    word_level_sbv.close()
    
    word_level_sbv內容 = word_level_sbv內容.replace('\n\n','\n')
    #先將兩個換行符號做替換,換成一個換行符號用來消除sbv檔中的空行
    
    word_level_sbv內容列表 = word_level_sbv內容.split('\n')
    #接著以換行符號做切割,分割出單字和時間其時間包含起始時間和結束時間
    
    時間列表 = []
    #創造時間列表用來存取時間
    
    單字列表 = []
    #創造單字列表用來存取單字
    
    for i in range(0,len(word_level_sbv內容列表),1):
    #用for迴圈分別將單字存入單字列表,將時間存入時間列表
        
        if i%2==0 and len(word_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後時間的部分在list中的單數元素
            
            時間列表.append(word_level_sbv內容列表[i])
            #所以將單數元素存入時間列表
            
        if i%2==1 and len(word_level_sbv內容列表[i])>0:
        #由於sbv經由上述的處理經由換行符號切割後單字的部分在list中的偶數元素
            
            單字列表.append(word_level_sbv內容列表[i])
            #所以將偶數元素存入單字列表
            
    時間字串 = ""
    #創造時間字串用來連接所有時間列表內的所有元素
    
    for i in range(0,len(時間列表),1):
    #用for迴圈依序將所有在時間列表內的元素做銜接
        
        時間字串+=時間列表[i]+","
        #並在元素之間加上逗號","
        
    時間列表2 =時間字串.split(',')
    #最後用逗號做切割產生時間列表
    
    開始時間 = []
    #創造開始時間用來存取每個單字在播放時的起始時間
    
    結束時間 = []
    #創造結束時間用來存取每個單字在播放時的結束時間
    
    暫存 = []
    #創造暫存用來存取單字語音同步資料字串
    
    for i in range(0,len(時間列表2),1):
    #用for迴圈分別將單字在播放時的起始時間存入開始時間,
    #單字在播放時的結束時間存入結束時間
        
        if i%2==0 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #單字在播放時的起始時間在時間列表2這個list的單數元素
            
            開始時間.append(時間列表2[i])
            #將單字在播放時的起始時間存入開始時間
            
        if i%2==1 and len(時間列表2[i])>0:
        #由於時間字串經由逗號做切割後
        #單字在播放時的結束時間在時間列表2這個list的偶數元素
            
            結束時間.append(時間列表2[i])
            #將單字在播放時的結束時間存入結束時間
            
    單字起始位置='1.0'
    #設定單字起始位置為'1.0'其1為列數0為行數
    
    for i in range(0,len(開始時間),1):
    #設立for迴圈將每個單字在畫面中的位置找出來
        
        單字 = 文章字[i]
        #依序將單字列表內的元素存入名為單字的變數
        
        單字起始位置 = 文字顯示區.search(單字,單字起始位置)
        #運用文字顯示區.search找出每個單字在文字顯示區的開始位置
        
        if not 單字起始位置:
        #設定判斷式假如找不到單字起始位置則跳出
            
            break
        
        單字起始位置和單字長度 = '%s+%dc' %(單字起始位置,len(單字))
        
        單字結束位置 = 文字顯示區.index(單字起始位置和單字長度)
        #將單字起始位置加上單字本身長度來計算出單字結束位置
        
        開始_時_分_秒 = 開始時間[i].split(':')
        #將開始時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        單字開始時間 = (int(開始_時_分_秒[0])*3600000
                      +int(開始_時_分_秒[1])*60000
                      +int(float(開始_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        結束_時_分_秒 = 結束時間[i].split(':')
        #將結束時間中的每個元素用冒號做切割(':')產生_時_分_秒
        
        單字結束時間 = (int(結束_時_分_秒[0])*3600000
                      +int(結束_時_分_秒[1])*60000
                      +int(float(結束_時_分_秒[2])*1000))
        #將_時_分_秒分別依millisecond做換算最後加總產生以millisecond為單位的時間
        
        單字語音同步資料字串 = (str(單字)+"||"
                             +str(單字起始位置)+"||"
                             +str(單字結束位置)+"||"
                             +str(單字開始時間)+"||"
                             +str(單字結束時間)+"\n")
        #將所有單字語音同步資料轉為字串存入名為單字語音同步資料字串的變數
        
        暫存.append(單字語音同步資料字串)
        #將所有句子語音同步資料字串依序加入暫存
        
        單字起始位置 = 單字結束位置
        #將單字結束位置設為單字起始位置準備找尋下一個單字的單字結束位置
        
    單字語音同步列表字串 = ''.join(i for i in 暫存)
    #用for迴圈將暫存中的單字語音同步資料字串依序做銜接
    
    del 暫存[:]
    
    del 結束時間[:]
    
    del 開始時間[:]
    
    del 單字列表[:]
    
    del 時間列表[:]
    
    return 單字語音同步列表字串

def 新增日文文章():
    文字顯示區.delete(1.0,END)
    try:
        成功.append("t")
        
        取得標點符號()
    
        製造資料夾()
    
        del 單字拼音[:]
    
        del 去除標點符號的單位句子[:]
    
        del 拼音句子[:]
    
        del 文章字[:]
    
        del 單位句子[:]
    
        del 單位句子中每個句子的檔案大小[:]
    
        桌面路徑=os.path.split(檔案路徑)[0]
    
        文字檔案所在的路徑 = askopenfilename(initialdir=桌面路徑)
        #用askopenfilename()取得被使用者所選取的文字檔的絕對路徑位置
    
        文字檔案名稱 = os.path.split(文字檔案所在的路徑)[1]
        #用os.path.split()取得路徑最後的文字檔案名稱
    
        名稱=文字檔案名稱.replace('.txt','')
        #去除文字檔的副檔名
    
        文章集.append(名稱)
        #將文字檔案的檔名加到文章集中
    
        檔案文件 = open(文字檔案所在的路徑,'r',encoding="utf8")
        #選擇檔案
    
        文章= 檔案文件.read()
        #讀取檔案文件的文字內容
    
        檔案文件.close()
        #讀取完檔案文件的文字內容將其關閉
    
        文字顯示區.delete(1.0,END)
        #首先為了確保畫面中的文字顯示區為淨空的狀態 
        #因此再插入文章內容時必須先清空文字顯示區
    
        文字顯示區.tag_configure('big',font=('Verdana',10,'bold'))
        #設定插入文章的文字大小及字型
    
        文字顯示區.insert(1.0,文章,'big')
        #將文章的文字內容從文字顯示區的1.0起始位置開始插入
    
        日文文字處理(文章)
    
        mecab日文斷詞()
    
        取得羅馬拼音的日文斷詞()
    
        for w in 文章字:
        
            w = w.strip()
        
        產生羅馬拼音的單位句子()
    
        for i in range(0,len(單位句子),1):
        
            if len(單位句子[i])==1:
            
                單位句子[i-1]=單位句子[i-1]+單位句子[i]
            
        for 句子 in 單位句子:
        
            if len(句子)==1:
            
                單位句子.remove(句子)
            
        for 句子 in 單位句子:
        
            句子 = 句子.strip()
        
        google日文語音合成(名稱+'.mp3')
    
        wav語音檔長度=mp3_to_wav()
    
        製做日文sentence_level_sbv檔(wav語音檔長度)
    
        CguAlign_wj_01.CguAlign主程式(文章集[-1])
    
        句子 = 製作日文句子語音同步列表(文字顯示區)
    
        單字 = 製做日文單字語音同步列表(文字顯示區)
    
        句子單字語音同步列表 = 句子+"@@"+單字
    
        句子單字語音同步列表存取位置 =  r'%s\%s'%(檔案路徑,"Output/tlt")
        #將檔案路徑做延伸到原有資料夾下的單字語音同步列表資料夾
    
        句子單字語音同步列表名稱 = 文章集[-1]+".tlt"
        #依照使用者所點選檔案的檔名來命名
    
        完整路徑名稱 = os.path.join(句子單字語音同步列表存取位置,
                句子單字語音同步列表名稱)
        #將語音同步列表檔存取位置及語音同步列表名稱做相加產生完整路徑名稱
    
        句子單字語音同步列表檔案 = open(完整路徑名稱,'w',encoding="utf-8")
        #運用完整路徑名稱創造檔案並採用寫入的模式
    
        句子單字語音同步列表檔案.write(句子單字語音同步列表)
        #將句子語音同步列表字串寫入句子語音同步列表檔案
    
        句子單字語音同步列表檔案.close()
        #寫入後將檔案關閉
    
        寫出路徑 = os.path.join('Output/article',文字檔案名稱)
    
        檔案文件 = open(寫出路徑,'w',encoding="utf-8")
    
        檔案文件.write(文章)
    
        檔案文件.close()
    
        刪除多餘資料夾(名稱)
    
        del 標點符號編碼[:]        
    except:

        成功.append("f")

        文字顯示區.delete(1.0,END)

        文字顯示區.tag_configure("big",font=('Verdana',20,'bold'))

        文字顯示區.insert(1.0,"抱歉!文章不能處理","big")

        check()
def 新增中文文章():
    文字顯示區.delete(1.0,END)
    try:

        成功.append("t")
        
        取得標點符號()
    
        製造資料夾()
    
        del 單字拼音[:]
    
        del 去除標點符號的單位句子[:]
    
        del 拼音句子[:]
    
        del 文章字[:]
    
        del 單位句子[:]
    
        del 單位句子中每個句子的檔案大小[:]
    
        桌面路徑=os.path.split(檔案路徑)[0]
    
        文字檔案所在的路徑 = askopenfilename(initialdir=桌面路徑)
        #用askopenfilename()取得被使用者所選取的文字檔的絕對路徑位置
    
        文字檔案名稱 = os.path.split(文字檔案所在的路徑)[1]
        #用os.path.split()取得路徑最後的文字檔案名稱
    
        名稱=文字檔案名稱.replace('.txt','')
        #去除文字檔的副檔名
    
        文章集.append(名稱)
        #將文字檔案的檔名加到文章集中
    
        檔案文件 = open(文字檔案所在的路徑,'r',encoding="utf-8")
        #選擇檔案
    
        文章= 檔案文件.read()
        #讀取檔案文件的文字內容
    
        檔案文件.close()
        #讀取完檔案文件的文字內容將其關閉
    
        文字顯示區.delete(1.0,END)
        #首先為了確保畫面中的文字顯示區為淨空的狀態 
        #因此再插入文章內容時必須先清空文字顯示區
    
        文字顯示區.tag_configure('big',font=('Verdana',10,'bold'))
        #設定插入文章的文字大小及字型
    
        文字顯示區.insert(1.0,文章,'big')
        #將文章的文字內容從文字顯示區的1.0起始位置開始插入
    
        中文文字處理(文章)
    
    
        google中文語音合成(名稱+'.mp3')
    
        wav語音檔長度=mp3_to_wav()
    
        取得文章中每個單字的拼音()
    
        製做中文sentence_levl_sbv檔(wav語音檔長度)
    
        CguAlign_wj_01.CguAlign主程式(文章集[-1])
    
        句子 = 製作中文句子語音同步列表(文字顯示區)
    
        單字 = 製做中文單字語音同步列表(文字顯示區)
       
        句子單字語音同步列表 = 句子+"@@"+單字
    
        句子單字語音同步列表存取位置 =  r'%s\%s'%(檔案路徑,"Output/tlt")
        #將檔案路徑做延伸到原有資料夾下的單字語音同步列表資料夾
    
        句子單字語音同步列表名稱 = 文章集[-1]+".tlt"
        #依照使用者所點選檔案的檔名來命名
    
        完整路徑名稱 = os.path.join(句子單字語音同步列表存取位置,
                句子單字語音同步列表名稱)
        #將語音同步列表檔存取位置及語音同步列表名稱做相加產生完整路徑名稱
    
        句子單字語音同步列表檔案 = open(完整路徑名稱,'w',encoding="utf-8")
        #運用完整路徑名稱創造檔案並採用寫入的模式
    
        句子單字語音同步列表檔案.write(句子單字語音同步列表)
        #將句子語音同步列表字串寫入句子語音同步列表檔案
    
        句子單字語音同步列表檔案.close()
        #寫入後將檔案關閉
    
        寫出路徑 = os.path.join('Output/article',文字檔案名稱)
    
        檔案文件 = open(寫出路徑,'w',encoding="utf-8")
    
        檔案文件.write(文章)
    
        檔案文件.close()
    
        刪除多餘資料夾(名稱)
    
        del 標點符號編碼[:]
    except:

        成功.append("f")

        文字顯示區.delete(1.0,END)

        文字顯示區.tag_configure('big',font=('Verdana',20,'bold'))

        文字顯示區.insert(1.0,"抱歉!文章不能處理",'big')

        check()
    
def 滑鼠動作(event):
    
    index = 文字顯示區.index("@%s,%s" %(event.x,event.y))
    #取得滑鼠在畫面中的座標
    
    ch = 文字顯示區.get(index)
    #取得滑鼠在畫面中的字元
    
    pos =  "%s/%s %s '%s'" % (event.x, event.y, index, ch)
    
    try:
        sel = "%s-%s" % (文字顯示區.index("sel.first"),
                         文字顯示區.index("sel.last"))
        #取得滑鼠所選取區域中的起始位置的起始位置及結束位置
        
    except Exception :
        
        sel = ""
        
    if len(sel)>0:
        
        滑鼠選擇區域 = sel.split("-")
        #將sel經由split("-")後的結果存入滑鼠選擇區域
        
        選取起始位置 = 滑鼠選擇區域[0]
        #sel經由切割後第一個元素就是選取起始位置
        
        選取結束位置 = 滑鼠選擇區域[1]
        #sel經由切割後第二個元素就是選取結束位置
        
        字開始位置=[]
        #設定字開始位置來存取單字播放列表中每個字在畫面中的起始位置
        
        字結束位置=[]
        #設定字結束位置來存取單字播放列表中每個字在畫面中的結束位置
        
        for n in range(0,len(單字播放列表),1):
        #用for迴圈將單字播放列表中每個字在畫面中的起始位置取出存入字開始位置
            
            單字起始位置 = 單字播放列表[n][1]
            
            字開始位置.append(單字起始位置)
        """    
        if 選取起始位置 not in 字開始位置:
        #假如選取起始位置不在字開始位置
            
            location=選取起始位置.split(".")
            #將位置中的行和列做分離
            
            行= int(location[1])+1
            #再將行數加1
            
            location[1]=行
            
            選取起始位置=str(location[0])+"."+str(location[1])
            #最後再將行和列做合併行成選取起始位置
        """    
        數字1=字開始位置.index(選取起始位置)
        #然後再用.index計算出選取起始位置是在第幾個位置
        
        播放起始時間=int(單字播放列表[數字1][3])
        #最後再用這個位置去取出時間點
        
        for n in range(0,len(單字播放列表),1):
        #用for迴圈將單字播放列表中每個字在畫面中的結束位置取出存入字結束位置
            
            單字結束位置 = 單字播放列表[n][2]
            
            字結束位置.append(單字結束位置)
            
        if 選取結束位置 not in 字結束位置:
        #假如選取起始位置不在字結束位置
            
            location2=選取結束位置.split(".")
            #將位置中的行和列做分離
            
            行2 = int(location2[1])-1
            #再將行數減1
            
            location2[1]=行2
            
            選取結束位置=str(location2[0])+"."+str(location2[1])
            #最後再將行和列做合併行成選取結束位置
            
        數字2=字結束位置.index(選取結束位置)
        #然後再用.index計算出選取結束位置是在第幾個位置
        
        播放結束時間=int(單字播放列表[數字2][4])
        #最後再用這個位置去取出時間點
        
        播放時間=(播放起始時間/1000)*2
        
        pygame.mixer.music.play(1,播放時間)
        
        while pygame.mixer.music.get_busy :
            
            語音播放時間 = pygame.mixer.music.get_pos()
            
            現在播放時間 = 語音播放時間+播放起始時間
            
            if 現在播放時間>播放結束時間:
                
                pygame.mixer.music.stop()
                
                break
        
def 製造資料夾():
    
    os.makedirs("cgualign_lite")
    
    os.makedirs("cgualign_lite/Input")
    
    os.makedirs('cgualign_lite/Output/切到句的srt檔')
    
    os.makedirs('cgualign_lite/Output/切到字的trs檔')
    
    os.makedirs('cgualign_lite/Output/切到字的lab檔')
    
    os.makedirs('cgualign_lite/Output/切到字的lrc檔')
    
    os.makedirs('cgualign_lite/Output/切到字的sbv檔')

def 刪除多餘資料夾(i):
    
    shutil.rmtree("cgualign_lite")
    
    shutil.rmtree("hmms_p")
    
    shutil.rmtree(i)
    
    os.remove("myHmmPro")

def 去除文字顯示區的效果():
    
    文字顯示區.tag_remove('highlight',句子播放列表[-1][1],句子播放列表[-1][2])
    
    文字顯示區.tag_remove('found',單字播放列表[-1][1],單字播放列表[-1][2])

def 文字顯示當n小於句子播放列表(現在語音播放時間,n,tmpBool):
    
    if (現在語音播放時間>=int(句子播放列表[n][3])
    and 現在語音播放時間<=int(句子播放列表[n][4])
    and tmpBool==True):
    #假設現在語音播放時間大於等於句子語音開始秒數
    #並小於等於句子語音結束秒數並設tmpbool為true
        
        if n>=1:
        #當n大於等於1時
            
            文字顯示區.tag_remove('highlight',
            句子播放列表[n-1][1],句子播放列表[n-1][2])
            #運用tag_remove()去除上一個句子的顯示效果
            
        文字顯示區.tag_add('highlight',句子播放列表[n][1],句子播放列表[n][2])
        #運用tag_add()顯示語音當下播放的句子
        
        文字顯示區.see(句子播放列表[n][2])
        #顯示文字顯示區的位置
        
        文字顯示區.update()
        #更新文字顯示區

def 文字顯示當n等於句子播放列表():
    
    文字顯示區.tag_remove('highlight',句子播放列表[-1][1],句子播放列表[-1][2])
    #運用tag_remove()去除最後一個句子的顯示效果
    
    文字顯示區.tag_remove('found',單字播放列表[-1][1],單字播放列表[-1][2])
    #運用tag_remove()去除最後一個單字的顯示效果

def 文字顯示當n2小於單字播放列表(現在語音播放時間,n2,tmpBool2):
    
    if (現在語音播放時間>=int(單字播放列表[n2][3])
    and 現在語音播放時間<=int(單字播放列表[n2][4])
    and tmpBool2==True):
    #假設現在語音播放時間大於等於單字語音開始秒數
    #並小於等於單字語音結束秒數並設tmpbool2為true
        
        if n2>=1:
        #當n2大於等於1時
            
            文字顯示區.tag_remove('found',
            單字播放列表[n2-1][1],單字播放列表[n2-1][2])
            #運用tag_remove()去除上個單字的顯示效果
            
            文字顯示區.tag_add('found',單字播放列表[n2][1],單字播放列表[n2][2])
            #運用tag_add()顯示語音當下播放的單字
            
            文字顯示區.see(單字播放列表[n2][2])
            #顯示文字顯示區的位置
            
            文字顯示區.update()
            #更新文字顯示區
            
def 文字顯示區當IsPaseBool等於False(n,n2):
    
    句子播放句數.append(n)
    #將現在播放在第幾個句子存入句子播放句數
    
    單字播放個數.append(n2)
    #將現在播放在第幾個單字存入單字播放個數
    
    n2 = int(單字播放個數[-1])
    #於是將剛剛發生暫停時的單字存入n2
    
    文字顯示區.tag_remove('found',單字播放列表[n2][1],單字播放列表[n2][2])
    #再用tag_remove將此單字的效果去除
    
    n = int(句子播放句數[-1])
    #於是將剛剛發生暫停時的句子存入n
    
    文字顯示區.tag_remove('highlight',句子播放列表[n][1],句子播放列表[n][2])
    #再用tag_remove將此句子的效果去除

def check():
    
    資料夾名稱="Output"
    
    Output完整名稱 = os.path.join(檔案路徑,資料夾名稱)
    
    if os.path.exists(Output完整名稱)==False:
        
        os.makedirs("Output")
        
        os.makedirs("Output/article")
        
        os.makedirs("Output/mp3")
        
        os.makedirs("Output/tlt")
        
    資料夾名稱2="cgualign_lite"
    
    cgualign_lite完整名稱 = os.path.join(檔案路徑,資料夾名稱2)
    
    if os.path.exists(cgualign_lite完整名稱)==True:
        
        shutil.rmtree("cgualign_lite")
        
    資料夾名稱3="hmms_p"
    
    hmms_p完整名稱 = os.path.join(檔案路徑,資料夾名稱3)
    
    if os.path.exists(hmms_p完整名稱)==True:
        
        shutil.rmtree("hmms_p")
        
    檔案名稱="myHmmPro"
    
    myHmmPro完整名稱 = os.path.join(檔案路徑,檔案名稱)
    
    if os.path.exists(myHmmPro完整名稱)==True:
        
        os.remove("myHmmPro")
        
    資料夾內容=os.listdir(檔案路徑)
    
    應存在的檔案 = ['CguAlign_wj_01.py',
                   'google_tts_voice_book_1121.py',
                   'LGO.py',
                   'Output',
                   'romkan',
                   '__pycache__',
                   '中文拼音對照表.txt',
                   '標點符號查詢表.txt',
                   "實驗結果.xlsx",
                   "測試文章"]
    
    for i in 資料夾內容:
        
        if i not in 應存在的檔案:

            try:
            
                shutil.rmtree(i)

            except:

                os.remove(i)
        
def main():
    """
    運用pyton tkinter中的Text及Menu來設計使用者的畫面
    """
    
    選項列 = Menu(操作畫面)
    #選項列加入root中
    
    操作畫面.config(menu=選項列)
    #顯示選項列
    
    檔案選項 = Menu(選項列)
    #檔案選項加入選項列
    
    選項列.add_cascade(label="檔案",menu=檔案選項)
    #顯示檔案選項
    
    檔案選項.add_command(label="新增英文文章",command =新增文章)
    
    檔案選項.add_command(label="新增中文文章",command =新增中文文章 )
    
    檔案選項.add_command(label="新增日文文章",command =新增日文文章 )
    
    按鍵1= Button(操作畫面,text="選擇文章",fg="green"
	      ,width=25,command=選擇文章).grid(row=0, column=0)
    
    按鍵2= Button(操作畫面,text="開始閱讀/暫停閱讀",fg="green"
	      ,width=25,command=開始閱讀).grid(row=0, column=1)
    
    文字顯示區.bind("<ButtonRelease>",滑鼠動作)
    
    文字顯示區.grid(row=2, column=0, columnspan=2) 
    #將文字顯示區給顯示在畫面中
    
    操作畫面.mainloop()
    #等待使用者做其他的動作

    

if __name__=='__main__':
    main()
